<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¥–ç›æŠ“æŠ“ä¹ - Buffå¢å¼ºç‰ˆ</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #222; 
            height: 100vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-family: "Microsoft YaHei", sans-serif; 
            overflow: hidden; 
            color: #fff;
        }
        
        /* ä¸»å¸ƒå±€å®¹å™¨ */
        #main-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        /* æ¸¸æˆå®¹å™¨ */
        #game-wrapper {
            position: relative;
            height: 95vh;
            aspect-ratio: 750/1334;
            background: linear-gradient(180deg, #fffbf0 0%, #e6f7ff 100%);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }

        canvas { width: 100%; height: 100%; display: block; }

        /* ä¾§è¾¹æ  */
        #side-panel {
            width: 260px;
            background: #333;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 90vh;
        }

        .panel-section {
            background: #444;
            padding: 15px;
            border-radius: 8px;
        }

        h3 { margin: 0 0 10px 0; color: #ff8fab; font-size: 16px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        
        /* è¿›åº¦æ¡æ ·å¼ */
        .progress-container {
            width: 100%;
            height: 24px;
            background: #222;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 2px solid #555;
            margin-top: 5px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s;
        }
        .progress-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ffff00;
            z-index: 2;
        }
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
        }
        
        /* Buff çŠ¶æ€å±•ç¤º */
        .buff-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            background: #555;
            padding: 8px;
            border-radius: 6px;
            opacity: 0.5;
            transition: all 0.3s;
        }
        .buff-item.active {
            opacity: 1;
            background: #666;
            border: 1px solid #ff8fab;
        }
        .buff-icon { font-size: 20px; width: 30px; text-align: center; }
        .buff-info { flex: 1; }
        .buff-timer { font-weight: bold; color: #ffd700; }

        /* è°ƒè¯•æ§åˆ¶é¡¹ */
        .control-group { margin-bottom: 8px; font-size: 12px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .control-group input { width: 100%; cursor: pointer; }
        .value-display { color: #ff8fab; font-weight: bold; }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        #game-over-modal h2 { font-size: 36px; margin-bottom: 10px; color: #ff8fab; }
        #game-over-modal p { font-size: 18px; color: #ccc; margin-bottom: 20px; }
        button.restart-btn {
            padding: 10px 30px;
            font-size: 20px;
            background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #333;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 154, 158, 0.4);
        }

        /* ç›²ç›’å±•ç¤º - å¢å¼ºç‰ˆ */
        #blind-box-result {
            margin: 20px 0;
            display: flex;
            gap: 15px; /* å¢åŠ é—´è· */
            justify-content: center;
            flex-wrap: wrap;
            min-height: 80px; /* é¢„ç•™é«˜åº¦ */
        }

        .blind-box-wrapper {
            position: relative;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ç›²ç›’çƒä½“çŠ¶æ€ */
        .blind-box-ball {
            position: absolute;
            width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, #b39ddb, #673ab7);
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            z-index: 2;
            transition: all 0.2s;
        }

        .blind-box-ball.shaking {
            animation: blind-shake 0.5s ease-in-out infinite;
        }

        .blind-box-ball.opened {
            animation: blind-vanish 0.3s forwards;
        }

        /* å¥–å“ Emoji çŠ¶æ€ */
        .blind-box-prize {
            position: absolute;
            font-size: 32px;
            z-index: 1;
            transform: scale(0); /* åˆå§‹ä¸å¯è§ */
        }

        .blind-box-prize.revealed {
            animation: prize-jump 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes blind-shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg) scale(1.05); }
            75% { transform: rotate(10deg) scale(1.05); }
        }

        @keyframes blind-vanish {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        @keyframes prize-jump {
            0% { transform: scale(0) translateY(20px); opacity: 0; }
            50% { transform: scale(1.2) translateY(-20px); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* --- æ–°å¢ï¼šæ¸¸æˆå†… HUD æ ·å¼ --- */
        #game-hud {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* æ”¹å›é¡¶éƒ¨å¯¹é½ */
        }

        /* é¡¶éƒ¨æ  */
        .hud-top-bar {
            width: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            padding: 10px 15px;
            border-radius: 16px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        /* å€’è®¡æ—¶æ ·å¼ */
        #hud-timer-container {
            display: none; /* é»˜è®¤éšè— */
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            margin-top: -4px;
        }
        #hud-timer-val {
            font-family: monospace;
            color: #00f2fe;
        }
        #hud-timer-val.urgent {
            color: #ff4444;
            animation: pulse-red 0.5s infinite;
        }

        /* éš¾åº¦å‡çº§å¼¹çª— */
        #difficulty-toast {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(90deg, #ff9a9e 0%, #fecfef 100%);
            padding: 15px 30px;
            border-radius: 50px;
            color: #fff;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            box-shadow: 0 0 20px rgba(255, 154, 158, 0.6);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s;
        }
        #difficulty-toast.show {
            animation: toast-pop 2s forwards;
        }

        @keyframes toast-pop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(1); opacity: 0; }
        }
        
        @keyframes pulse-red {
            0% { transform: scale(1); text-shadow: 0 0 5px #ff4444; }
            50% { transform: scale(1.2); text-shadow: 0 0 20px #ff0000; }
            100% { transform: scale(1); text-shadow: 0 0 5px #ff4444; }
        }

        /* ç«ç„°ç‰¹æ•ˆ */
        .hud-progress-track.on-fire {
            box-shadow: 0 0 15px #ff5500, 0 0 30px #ffcc00;
            border: 1px solid #ffcc00;
        }
        .hud-progress-fill.on-fire {
            background: linear-gradient(90deg, #ff5500, #ffcc00, #ffff00);
            animation: fire-flow 1s linear infinite;
        }
        @keyframes fire-flow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        .hud-score-container {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            color: white;
        }
        .hud-score-label {
            font-size: 14px;
            color: #aaa;
            font-weight: bold;
            letter-spacing: 1px;
        }
        #hud-score-text {
            font-size: 32px;
            font-weight: 900;
            color: #4facfe;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
            font-family: 'Segoe UI', sans-serif;
        }

        /* ä¿®å¤è¿›åº¦æ¡æ ·å¼ï¼šç¡®ä¿å®ƒå­˜åœ¨ */
        .hud-progress-track {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            width: 100%; /* ç¡®ä¿å®½åº¦ */
        }
        .hud-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .hud-progress-marker {
            position: absolute;
            top: 0; bottom: 0; width: 2px;
            background: #ff9a9e;
            box-shadow: 0 0 5px #ff9a9e;
        }

        /* ç›²ç›’è®¡æ•° (å³ä¸Šè§’æ‚¬æµ®) */
        .hud-blind-box {
            position: absolute;
            top: 110px; 
            right: 20px;
            bottom: auto; /* æ¸…é™¤åº•éƒ¨å®šä½ */
            background: rgba(0,0,0,0.6);
            border-radius: 30px;
            padding: 5px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            border: 1px solid #555;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Buff åˆ—è¡¨ (å·¦ä¸Šè§’æ‚¬æµ®) */
        .hud-buff-list {
            position: absolute;
            top: 110px;
            left: 20px;
            bottom: auto; /* æ¸…é™¤åº•éƒ¨å®šä½ */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .hud-buff-item {
            background: rgba(0,0,0,0.7);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            opacity: 0; /* é»˜è®¤éšè— */
            transform: translateX(-20px);
            transition: all 0.3s;
            pointer-events: auto; /* å…è®¸æ‚¬åœæŸ¥çœ‹ä¿¡æ¯(å¦‚æœéœ€è¦) */
        }
        .hud-buff-item.active {
            opacity: 1;
            transform: translateX(0);
            border-left: 3px solid #ffd700;
        }
        .hud-buff-item .icon { font-size: 24px; }
        .hud-buff-item .timer { 
            font-size: 16px; 
            font-weight: bold; 
            font-variant-numeric: tabular-nums;
            color: #ffd700;
        }
    </style>
</head>
<body>

<div id="main-container">
    <!-- ä¾§è¾¹ä¿¡æ¯æ  -->
    <div id="side-panel">
        <div class="panel-section">
            <h3>å½“å‰åˆ†æ•°</h3>
            <div style="text-align: center; font-size: 28px; font-weight: bold; color: #4facfe;" id="score-text">0</div>
            <div class="progress-container">
                <div class="progress-fill" id="progress-fill"></div>
                <!-- 2000åˆ†æ ‡è®° (40%) -->
                <div class="progress-marker" style="left: 40%; background: #ff9a9e;" title="é€šå…³çº¿"></div>
            </div>
            <div class="progress-label">
                <span>0</span>
                <span style="color:#ff9a9e">2000(é€šå…³)</span>
                <span>5000(æ»¡çº§)</span>
            </div>
        </div>

        <div class="panel-section">
            <h3>Buff çŠ¶æ€</h3>
            <div id="buff-list">
                <div class="buff-item" id="buff-speed">
                    <span class="buff-icon">âš¡</span>
                    <div class="buff-info">æ€¥é€Ÿç‹‚é£™</div>
                    <span class="buff-timer" id="timer-speed">--</span>
                </div>
                <div class="buff-item" id="buff-slow">
                    <span class="buff-icon">ğŸ¢</span>
                    <div class="buff-info">æ—¶é—´å†»ç»“</div>
                    <span class="buff-timer" id="timer-slow">--</span>
                </div>
                <div class="buff-item" id="buff-power">
                    <span class="buff-icon">ğŸ’ª</span>
                    <div class="buff-info">å¤§åŠ›ç¥çˆª</div>
                    <span class="buff-timer" id="timer-power">--</span>
                </div>
                <div class="buff-item" id="buff-abyss">
                    <span class="buff-icon">ğŸ¦–</span>
                    <div class="buff-info">æ·±æ¸Šå·¨çˆª</div>
                    <span class="buff-timer" id="timer-abyss">--</span>
                </div>
                <!-- æ–°å¢ï¼šç›²ç›’è®¡æ•°æ˜¾ç¤º -->
                <div class="buff-item" style="opacity: 1; border: 1px solid #aaa;">
                    <span class="buff-icon">â“</span>
                    <div class="buff-info">å·²æ”¶é›†ç›²ç›’</div>
                    <span class="buff-timer" id="blind-box-count-ui" style="color: #ff9a9e;">0</span>
                </div>
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #888;">
                <p>âš¡ åŠ é€Ÿ | ğŸ¢ å‡é€Ÿ | ğŸ’ª è¿æŠ“</p>
                <p>ğŸ¦– å·¨çˆª: ç©¿é€é”€æ¯ (5s)</p>
                <p>ğŸ’ ç§˜é“¶: æ¶ˆé™¤+5000åˆ†</p>
                <p>ğŸŒˆ ä¸‡èƒ½: åŒ¹é…ä»»æ„é¢œè‰²</p>
                <p>ğŸ’£ ç‚¸å¼¹: æ¸…é™¤å…¶ä»–çƒ</p>
            </div>
        </div>

        <div class="panel-section" id="debug-controls">
            <h3>å¼€å‘è€…æ§åˆ¶å°</h3>
            <div class="control-group">
                <label>è½¨é“å½¢çŠ¶</label>
                <select id="inp-trackShape" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="sine">æ³¢æµª (ç®€å•)</option>
                    <option value="spiral">èºæ—‹ (æŒ‘æˆ˜)</option>
                    <option value="circle">å¤§å›ç¯</option>
                    <option value="infinity" selected>æ— é™ (âˆ)</option>
                    <option value="heart">çˆ±å¿ƒ</option>
                </select>
            </div>
            <div class="control-group">
                <label>åŸºç¡€çƒé€Ÿ <span id="val-speed" class="value-display">0.5</span></label>
                <input type="range" id="inp-speed" min="0.5" max="5" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>ç”Ÿæˆé—´éš” <span id="val-spawn" class="value-display">500</span></label>
                <input type="range" id="inp-spawn" min="500" max="3000" step="100" value="500">
            </div>
            
            <div style="border-top: 1px solid #555; margin: 10px 0;"></div>

            <div class="control-group">
                <label>æ¶ˆé™¤æ¨¡å¼</label>
                <select id="inp-matchMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="match2">äºŒæ¶ˆ (5æ§½)</option>
                    <option value="match3" selected>ä¸‰æ¶ˆ (å¯é…)</option>
                </select>
            </div>
            <div class="control-group" id="group-slotLimit">
                <label>æ§½ä½ä¸Šé™ <span id="val-slotLimit" class="value-display">9</span></label>
                <input type="range" id="inp-slotLimit" min="7" max="9" step="1" value="9">
            </div>
            <div class="control-group">
                <label>å…³å¡æ¨¡å¼</label>
                <select id="inp-levelMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="random">éšæœºç”Ÿæˆ</option>
                    <option value="fixed" selected>å›ºå®šå…³å¡</option>
                    <option value="time_limit">â±ï¸ é™æ—¶æŒ‘æˆ˜</option>
                </select>
            </div>
            <div class="control-group">
                <label>æ“ä½œæ¨¡å¼</label>
                <select id="inp-controlMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="auto">è‡ªåŠ¨æ‘†åŠ¨</option>
                    <option value="mouse">PCç«¯æ“ä½œ (é¼ æ ‡)</option>
                    <option value="touch" selected>ç§»åŠ¨ç«¯æ“ä½œ (è§¦æ‘¸)</option>
                </select>
            </div>
            
            <div style="border-top: 1px solid #555; margin: 10px 0;"></div>
            
            <div class="control-group">
                <label>Debug: ä¸‹ä¸ªçƒ Buff</label>
                <select id="inp-nextBuff" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="none">éšæœº (é»˜è®¤)</option>
                    <option value="mystery">â“ ç›²ç›’</option>
                    <option value="speed">âš¡ åŠ é€Ÿ</option>
                    <option value="slow">ğŸ¢ å‡é€Ÿ</option>
                    <option value="power">ğŸ’ª å¤§åŠ›</option>
                    <option value="abyss">ğŸ¦– æ·±æ¸Š</option>
                    <option value="mythril">ğŸ’ ç§˜é“¶</option>
                    <option value="rainbow">ğŸŒˆ ä¸‡èƒ½</option>
                    <option value="bomb">ğŸ’£ ç‚¸å¼¹</option>
                </select>
            </div>
            <div class="control-group">
                <label>Debug: é¢œè‰²æ•°é‡ <span id="val-colorCount" class="value-display">6</span></label>
                <input type="range" id="inp-colorCount" min="3" max="6" step="1" value="6">
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»åŒºåŸŸ -->
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="750" height="1334"></canvas>
        
        <!-- æ–°å¢ï¼šæ¸¸æˆå†… HUD å±‚ -->
        <div id="game-hud">
            <!-- é¡¶éƒ¨æ ï¼šåˆ†æ•°ä¸è¿›åº¦ -->
            <div class="hud-top-bar">
                <!-- å€’è®¡æ—¶ (é™æ—¶æ¨¡å¼æ˜¾ç¤º) -->
                <div id="hud-timer-container">
                    â³ <span id="hud-timer-val">90.0</span>s
                </div>

                <div class="hud-score-container">
                    <span class="hud-score-label">SCORE</span>
                    <span id="hud-score-text">0</span>
                </div>
                <div class="hud-progress-track" id="hud-progress-track">
                    <div class="hud-progress-fill" id="hud-progress-fill"></div>
                    <!-- è¿›åº¦æ¡æ ‡è®°ï¼šé»˜è®¤æ¨¡å¼ -->
                    <div class="hud-progress-marker marker-default" style="left: 40%"></div>
                    <!-- è¿›åº¦æ¡æ ‡è®°ï¼šé™æ—¶æ¨¡å¼ (åŠ¨æ€æ·»åŠ æˆ–é¢„è®¾éšè—) -->
                    <div class="hud-progress-marker marker-time" style="left: 20%; display:none; background:#ffff00;"></div>
                    <div class="hud-progress-marker marker-time" style="left: 60%; display:none; background:#ff5500;"></div>
                </div>
            </div>

            <!-- éš¾åº¦å‡çº§æç¤º -->
            <div id="difficulty-toast">éš¾åº¦å‡çº§! é€Ÿåº¦UP!</div>

            <!-- å·¦ä¾§ï¼šBuff çŠ¶æ€æ  -->
            <div class="hud-buff-list">
                <div class="hud-buff-item" id="hud-buff-speed">
                    <div class="icon">âš¡</div>
                    <div class="timer" id="hud-timer-speed">0.0s</div>
                </div>
                <div class="hud-buff-item" id="hud-buff-slow">
                    <div class="icon">ğŸ¢</div>
                    <div class="timer" id="hud-timer-slow">0.0s</div>
                </div>
                <div class="hud-buff-item" id="hud-buff-power">
                    <div class="icon">ğŸ’ª</div>
                    <div class="timer" id="hud-timer-power">0.0s</div>
                </div>
                <div class="hud-buff-item" id="hud-buff-abyss">
                    <div class="icon">ğŸ¦–</div>
                    <div class="timer" id="hud-timer-abyss">0.0s</div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šç›²ç›’è®¡æ•° -->
            <div class="hud-blind-box">
                <span class="icon">â“</span>
                <span class="count" id="hud-blind-count">0</span>
            </div>

            <!-- åº•éƒ¨æç¤ºè¯­ -->
            <div style="position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none;">
                <span style="background: rgba(0, 0, 0, 0.6); color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: bold; backdrop-filter: blur(2px); box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
                    æŒ‰ä½å±å¹•ç§»åŠ¨æŠ“é’©ï¼Œæ¾æ‰‹æŠ“é’©ä¸‹è½
                </span>
            </div>
        </div>
        
        <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
        <div id="game-over-modal">
            <h2 id="modal-title">æ¸¸æˆç»“æŸ</h2>
            <p id="modal-desc">å¾—åˆ†: 100</p>
            <div id="blind-box-area" style="display:none;">
                <p style="font-size:14px; color:#ff9a9e;">å¼€å¯äº† <span id="box-count">0</span> ä¸ªç›²ç›’!</p>
                <div id="blind-box-result"></div>
            </div>
            <button class="restart-btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>
</div>

<script>
    /**
     * æ¸¸æˆé…ç½®
     */
    const GameConfig = {
        ballSpeed: 0.5,
        ballSpawnInterval: 500,
        clawPatrolSpeed: 8,
        clawDropSpeed: 25,
        
        trackBaseY: 1000,
        trackAmplitude: 120,
        trackFrequency: 0.01,
        trackShape: 'infinity',
        
        // Pastel (ç²‰å½©) è‰²ç³»ï¼šæŸ”å’ŒæŠ¤çœ¼ä¸”åŒºåˆ†åº¦é«˜
        colors: ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E2BAFF'],
        activeColorCount: 6, // å½“å‰ä½¿ç”¨çš„é¢œè‰²æ•°é‡
        
        // åˆ†æ•°ç³»ç»Ÿ
        maxScore: 5000,
        passScore: 2000,
        
        // Buff å‚æ•°
        buffProbability: 0.15, // 15% æ¦‚ç‡å‡º Buff
        buffDuration: 5.0,      // 5ç§’
        
        // æ–°å¢æ¨¡å¼é…ç½®
        matchMode: 'match3',   // match2 | match3
        slotLimit: 9,          // 5 | 7-9
        levelMode: 'fixed',   // random | fixed | time_limit
        controlMode: 'touch',   // auto | mouse | touch
        fixedBallCount: 30,     // å›ºå®šå…³å¡åˆå§‹çƒæ•°
        
        // é™æ—¶æ¨¡å¼å‚æ•°
        timeLimit: 90,          // 90ç§’
        difficultyLevels: [1000, 3000] // éš¾åº¦å‡çº§åˆ†æ•°çº¿
    };

    // è¾…åŠ©è·å–å½“å‰æ¨¡å¼å‚æ•°
    const getMatchThreshold = () => GameConfig.matchMode === 'match3' ? 3 : 2;
    const getMaxSlots = () => GameConfig.slotLimit;

    const BUFF_TYPES = {
        NONE: 'none',
        MYSTERY: 'mystery', // â“
        SPEED: 'speed',     // âš¡
        SLOW: 'slow',       // ğŸ¢
        POWER: 'power',     // ğŸ’ª
        ABYSS: 'abyss',     // ğŸ¦– æ·±æ¸Šå·¨çˆª
        MYTHRIL: 'mythril', // ğŸ’ ç§˜é“¶
        RAINBOW: 'rainbow', // ğŸŒˆ ä¸‡èƒ½
        BOMB: 'bomb'        // ğŸ’£ ç‚¸å¼¹
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // å…¨å±€çŠ¶æ€
    let score = 0;
    let lastTime = 0;
    let ballTimer = 0;
    let pathPoints = []; 
    let balls = [];
    let slots = [];
    let particles = [];
    let isGameOver = false;
    let blindBoxCount = 0;
    let isDragging = false; // æ–°å¢ï¼šæ‹–æ‹½çŠ¶æ€
    let inputTargetX = 375; // æ–°å¢ï¼šPCé¼ æ ‡ç›®æ ‡ä½ç½®(ç”¨äºå¹³æ»‘è·Ÿéš)
    
    // é™æ—¶æ¨¡å¼çŠ¶æ€
    let gameTimeLeft = 0;
    let currentDiffLevel = 0; // 0, 1, 2...
    let highScoreTimeLimit = parseInt(localStorage.getItem('claw_machine_highscore_time') || '0');
    
    // Debug çŠ¶æ€
    let debugNextBuff = null;

    // Buff çŠ¶æ€ (å‰©ä½™ç§’æ•°)
    let activeBuffs = {
        speed: 0,
        slow: 0,
        power: 0,
        abyss: 0
    };
    
    // æŠ“é’©å¯¹è±¡
    const claw = {
        x: 375, y: 350, originY: 350, // ä¸‹ç§»æŠ“é’©èµ·å§‹ç‚¹ (åŸ 250 -> 350)
        state: 'IDLE', direction: 1, 
        heldBalls: [] // æ”¹ä¸ºæ•°ç»„ï¼Œæ”¯æŒæŠ“å¤šä¸ª
    };

    // --- UI æ§åˆ¶ ---
    function updateScoreUI() {
        // æ›´æ–°å·¦ä¾§é¢æ¿ (æ—§)
        const scoreEl = document.getElementById('score-text');
        if (scoreEl) scoreEl.innerText = score;
        
        let pct = 0;
        
        if (GameConfig.levelMode === 'time_limit') {
            // é™æ—¶æ¨¡å¼è¿›åº¦æ¡é€»è¾‘
            // åŸºç¡€ 5000 åˆ†æ»¡
            pct = Math.min(100, (score / 5000) * 100);
            
            // æ— é™æ¨¡å¼ç«ç„°ç‰¹æ•ˆ
            const track = document.getElementById('hud-progress-track');
            const fill = document.getElementById('hud-progress-fill');
            
            if (score >= 5000) {
                if (track) track.classList.add('on-fire');
                if (fill) fill.classList.add('on-fire');
            } else {
                if (track) track.classList.remove('on-fire');
                if (fill) fill.classList.remove('on-fire');
            }
        } else {
            // æ™®é€šæ¨¡å¼
            pct = Math.min(100, (score / GameConfig.maxScore) * 100);
            // ç§»é™¤ç‰¹æ•ˆ
             const track = document.getElementById('hud-progress-track');
             const fill = document.getElementById('hud-progress-fill');
             if (track) track.classList.remove('on-fire');
             if (fill) fill.classList.remove('on-fire');
        }

        const progFill = document.getElementById('progress-fill');
        if (progFill) progFill.style.width = pct + '%';

        // æ›´æ–°æ¸¸æˆå†… HUD (æ–°)
        const hudScore = document.getElementById('hud-score-text');
        if (hudScore) hudScore.innerText = score;
        
        const hudFill = document.getElementById('hud-progress-fill');
        if (hudFill) hudFill.style.width = pct + '%';
        
        // å®æ—¶æ£€æŸ¥æ»¡çº§ (ä»…éé™æ—¶æ¨¡å¼)
        if (GameConfig.levelMode !== 'time_limit' && score >= GameConfig.maxScore && !isGameOver) {
            gameOver(true, 'FULL');
        }
    }

    // æ–°å¢ï¼šéš¾åº¦å‡çº§æ£€æµ‹
    function checkDifficultyUp() {
        // Levels: [1000, 3000]
        const levels = GameConfig.difficultyLevels;
        
        // æ£€æŸ¥æ˜¯å¦åˆšåˆšè·¨è¿‡é˜ˆå€¼
        // ç®€å•é€»è¾‘ï¼šæ ¹æ®å½“å‰åˆ†æ•°åˆ¤æ–­åº”è¯¥åœ¨å“ªä¸ª Level
        let newLevel = 0;
        if (score >= levels[1]) newLevel = 2;
        else if (score >= levels[0]) newLevel = 1;
        
        if (newLevel > currentDiffLevel) {
            currentDiffLevel = newLevel;
            // è§¦å‘éš¾åº¦å‡çº§
            adjustDifficulty(newLevel);
            showDifficultyToast(newLevel);
        }
    }
    
    function adjustDifficulty(level) {
        // æ ¹æ®ç­‰çº§åŠ é€Ÿ
        if (level === 1) {
             GameConfig.ballSpeed = 0.8; // 0.5 -> 0.8
             GameConfig.ballSpawnInterval = 400; // 500 -> 400
        } else if (level === 2) {
             GameConfig.ballSpeed = 1.2;
             GameConfig.ballSpawnInterval = 300;
        }
    }
    
    function showDifficultyToast(level) {
        const toast = document.getElementById('difficulty-toast');
        const texts = ["", "éš¾åº¦å‡çº§! LV.2", "éš¾åº¦å‡çº§! MAX!"];
        toast.innerText = texts[level] || "éš¾åº¦å‡çº§!";
        
        toast.classList.remove('show');
        void toast.offsetWidth; // trigger reflow
        toast.classList.add('show');
    }

    function updateBuffUI() {
        // Helper to update specific buff item
        const updateItem = (type, timer) => {
            // æ›´æ–°å·¦ä¾§é¢æ¿ (æ—§)
            const el = document.getElementById('buff-' + type);
            const timerEl = document.getElementById('timer-' + type);
            if (timer > 0) {
                el.classList.add('active');
                timerEl.innerText = timer.toFixed(1) + 's';
            } else {
                el.classList.remove('active');
                timerEl.innerText = '--';
            }

            // æ›´æ–°æ¸¸æˆå†… HUD (æ–°)
            const hudEl = document.getElementById('hud-buff-' + type);
            const hudTimer = document.getElementById('hud-timer-' + type);
            if (hudEl && hudTimer) {
                if (timer > 0) {
                    hudEl.classList.add('active');
                    hudTimer.innerText = timer.toFixed(1) + 's';
                } else {
                    hudEl.classList.remove('active');
                }
            }
        };

        updateItem('speed', activeBuffs.speed);
        updateItem('slow', activeBuffs.slow);
        updateItem('power', activeBuffs.power);
        updateItem('abyss', activeBuffs.abyss);
    }

    function updateBlindBoxUI() {
        const el = document.getElementById('blind-box-count-ui');
        if (el) el.innerText = blindBoxCount;
        
        // æ›´æ–°æ¸¸æˆå†… HUD (æ–°)
        const hudEl = document.getElementById('hud-blind-count');
        if (hudEl) hudEl.innerText = blindBoxCount;
    }

    // --- æ¸¸æˆé€»è¾‘ç±» ---

    class Ball {
        constructor() {
            this.pathIndex = 0;
            
            // Debug: é™åˆ¶é¢œè‰²æ•°é‡
            const colorLimit = Math.min(GameConfig.colors.length, GameConfig.activeColorCount);
            this.color = GameConfig.colors[Math.floor(Math.random() * colorLimit)];
            
            this.markedForDeletion = false;
            
            // éšæœºåˆ†é… Buff - åŸºäºéš¾åº¦æå‡æ¦‚ç‡
            this.buff = BUFF_TYPES.NONE;
            
            // Debug: å¼ºåˆ¶ Buff
            if (debugNextBuff && debugNextBuff !== 'none') {
                this.buff = debugNextBuff;
                debugNextBuff = null; // æ¶ˆè´¹æ‰
                // é‡ç½® UI
                const el = document.getElementById('inp-nextBuff');
                if(el) el.value = 'none';
            } else {
                let prob = GameConfig.buffProbability;
                // éš¾åº¦åŠ æˆ: Lv0=+0, Lv1=+5%, Lv2=+10%
                if (GameConfig.levelMode === 'time_limit') {
                    prob += currentDiffLevel * 0.05;
                }
                
                if (Math.random() < prob) {
                    // æ„å»º Buff æ± ä¸æƒé‡
                    let pool = [];
                    
                    // æ™®é€š (æƒé‡ 10)
                    pool.push({type: BUFF_TYPES.SPEED, w: 10});
                    pool.push({type: BUFF_TYPES.SLOW, w: 10});
                    pool.push({type: BUFF_TYPES.POWER, w: 10});
                    
                    // ç¨€æœ‰ (æƒé‡ 5)
                    pool.push({type: BUFF_TYPES.MYTHRIL, w: 5});
                    pool.push({type: BUFF_TYPES.RAINBOW, w: 5});
                    pool.push({type: BUFF_TYPES.BOMB, w: 5});
                    
                    // ä¼ è¯´ (æƒé‡ 2)
                    pool.push({type: BUFF_TYPES.ABYSS, w: 2});
                    
                    // æ¨¡å¼è¿‡æ»¤
                    if (GameConfig.levelMode === 'time_limit') {
                         // é™æ—¶æ¨¡å¼: æ— ç›²ç›’
                    } else {
                         // æ™®é€šæ¨¡å¼: åŠ ç›²ç›’ (æƒé‡ 8)
                         pool.push({type: BUFF_TYPES.MYSTERY, w: 8});
                    }
                    
                    // æƒé‡éšæœº
                    let totalW = pool.reduce((a,b) => a+b.w, 0);
                    let r = Math.random() * totalW;
                    let sum = 0;
                    for(let p of pool) {
                        sum += p.w;
                        if (r < sum) {
                            this.buff = p.type;
                            break;
                        }
                    }
                }
            }
            
            this.updatePos();
        }

        updatePos() {
            const idx = Math.floor(this.pathIndex);
            if (idx < pathPoints.length) {
                this.x = pathPoints[idx].x;
                this.y = pathPoints[idx].y;
            } else {
                if (GameConfig.levelMode === 'fixed') {
                    // å›ºå®šæ¨¡å¼ï¼šå¾ªç¯
                    this.pathIndex = 0;
                    this.updatePos();
                } else {
                    // éšæœºæ¨¡å¼ï¼šé”€æ¯
                    this.markedForDeletion = true;
                }
            }
        }

        update(dtMultiplier) {
            // åº”ç”¨å…¨å±€é€Ÿåº¦å€ç‡ (ä»… Slow Buff å½±å“çƒé€Ÿï¼ŒSpeed Buff ç°åœ¨å½±å“æŠ“é’©)
            // å¦‚æœ dtMultiplier æ˜¯ä» update() ä¼ å…¥çš„ï¼Œéœ€è¦ç¡®è®¤å…¶é€»è¾‘ã€‚
            // ä¹‹å‰çš„ update() é€»è¾‘æ˜¯ï¼šå¦‚æœæœ‰ speed buff, mult=2; slow buff, mult=0.5
            // æˆ‘ä»¬å°†åœ¨å¤–éƒ¨ update() ä¿®æ”¹æ­¤é€»è¾‘ï¼Œè¿™é‡Œä¿æŒæ¥æ”¶å€ç‡å‚æ•°
            this.pathIndex += GameConfig.ballSpeed * dtMultiplier;
            this.updatePos();
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 40, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // ç»˜åˆ¶ Buff å›¾æ ‡
            if (this.buff !== BUFF_TYPES.NONE) {
                // ç§»é™¤é®ç½©ï¼Œç›´æ¥ç»˜åˆ¶æ–‡å­—
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let symbol = '';
                switch(this.buff) {
                    case BUFF_TYPES.MYSTERY: symbol = 'â“'; break;
                    case BUFF_TYPES.SPEED: symbol = 'âš¡'; break;
                    case BUFF_TYPES.SLOW: symbol = 'ğŸ¢'; break;
                    case BUFF_TYPES.POWER: symbol = 'ğŸ’ª'; break;
                    case BUFF_TYPES.ABYSS: symbol = 'ğŸ¦–'; break;
                    case BUFF_TYPES.MYTHRIL: symbol = 'ğŸ’'; break;
                    case BUFF_TYPES.RAINBOW: symbol = 'ğŸŒˆ'; break;
                    case BUFF_TYPES.BOMB: symbol = 'ğŸ’£'; break;
                }
                
                // æè¾¹ä»¥å¢å¼ºåœ¨æµ…è‰²èƒŒæ™¯ä¸Šçš„å¯è§æ€§
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.strokeText(symbol, this.x, this.y + 2);
                
                ctx.fillStyle = '#fff';
                ctx.fillText(symbol, this.x, this.y + 2); 
            }
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random()-0.5)*15;
            this.vy = (Math.random()-0.5)*15;
            this.life = 1;
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
        draw(ctx) {
            if(this.life<=0) return;
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- æ ¸å¿ƒåŠŸèƒ½ ---

    function initPath() {
        pathPoints = [];
        balls = []; // æ¯æ¬¡é‡ç½®è·¯å¾„æ—¶æ¸…ç©ºçƒ
        
        let shape = GameConfig.trackShape;
        let cx = 375, cy = 800; // åŸ 700 -> 800
        
        if (shape === 'sine') {
            for (let x = -100; x <= 850; x += 5) {
                let y = GameConfig.trackBaseY 
                      + Math.sin(x * GameConfig.trackFrequency) * GameConfig.trackAmplitude 
                      + (x * 0.1);
                pathPoints.push({x, y});
            }
        } 
        else if (shape === 'spiral') {
            cy = 700; // åŸ 600 -> 700
            let radius = 10;
            let angle = 0;
            for (let i = 0; i < 600; i++) {
                angle += 0.1; radius += 0.5;
                let x = cx + radius * Math.cos(angle);
                let y = cy + radius * Math.sin(angle);
                pathPoints.push({x, y});
            }
        }
        else if (shape === 'circle') {
             const r = 300;
             for (let i = 0; i < 360; i++) {
                 let rad = (i - 90) * (Math.PI / 180); 
                 let x = cx + r * Math.cos(rad);
                 let y = cy + r * Math.sin(rad);
                 pathPoints.push({x, y});
             }
        }
        else if (shape === 'infinity') {
            const a = 300;
            for (let t = 0; t < Math.PI * 2; t += 0.02) {
                const denom = 1 + Math.sin(t) * Math.sin(t);
                let x = cx + (a * Math.cos(t)) / denom;
                let y = cy + (a * Math.sin(t) * Math.cos(t)) / denom;
                pathPoints.push({x, y});
            }
        }
        else if (shape === 'heart') {
            cy = 750; // åŸ 650 -> 750
            const scale = 15;
            for (let t = 0; t < Math.PI * 2; t += 0.02) {
                let x = cx + scale * (16 * Math.pow(Math.sin(t), 3));
                let y = cy - scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                pathPoints.push({x, y});
            }
        }

        // å›ºå®šå…³å¡åˆå§‹åŒ–ï¼šé¢„ç”Ÿæˆçƒä½“
        if (GameConfig.levelMode === 'fixed') {
            // ç¡®ä¿è·¯å¾„ç”Ÿæˆå®Œæ¯•
            if (pathPoints.length > 0) {
                const totalBalls = GameConfig.fixedBallCount;
                // å‡åŒ€åˆ†å¸ƒåœ¨æ•´ä¸ªè·¯å¾„ä¸Š
                // ä¸ºé˜²æ­¢é¦–å°¾ç›¸æ¥å¤ªç´§ï¼Œç•™å‡ºä¸€æ®µç¼“å†²
                const step = Math.floor(pathPoints.length / totalBalls);
                
                for(let i=0; i<totalBalls; i++) {
                    let b = new Ball();
                    // å¼ºåˆ¶è®¾ç½® pathIndex
                    b.pathIndex = i * step;
                    b.updatePos();
                    balls.push(b);
                }
            }
        }
    }

    function findConnectedBalls(startBall) {
        // æŸ¥æ‰¾ä¸ startBall é¢œè‰²ç›¸åŒä¸”åœ¨è·¯å¾„ä¸Šç›¸é‚»çš„çƒ
        // ç®€å•å®ç°ï¼šæŒ‰è·¯å¾„ç´¢å¼•æ’åºï¼Œç„¶åå‘å‰åæœç´¢
        // 1. è·å–æ‰€æœ‰çƒå¹¶æŒ‰ pathIndex æ’åº
        let sortedBalls = [...balls].sort((a, b) => a.pathIndex - b.pathIndex);
        let targetIdx = sortedBalls.indexOf(startBall);
        if (targetIdx === -1) return [startBall];

        let connected = [startBall];
        
        // å‘å‰æœ
        for (let i = targetIdx - 1; i >= 0; i--) {
            let b = sortedBalls[i];
            let prevB = sortedBalls[i+1]; // ä¸Šä¸€ä¸ªåŠ å…¥çš„çƒï¼ˆé€»è¾‘ä¸Šæ˜¯åä¸€ä¸ªä½ç½®ï¼‰
            // è·ç¦»åˆ¤å®š (ç›´å¾„80ï¼Œç¨å¾®æ”¾å®½åˆ°90)
            let dist = Math.hypot(b.x - prevB.x, b.y - prevB.y);
            if (b.color === startBall.color && dist < 90) {
                connected.push(b);
            } else {
                break; // æ–­å¼€
            }
        }
        
        // å‘åæœ
        for (let i = targetIdx + 1; i < sortedBalls.length; i++) {
            let b = sortedBalls[i];
            let prevB = sortedBalls[i-1];
            let dist = Math.hypot(b.x - prevB.x, b.y - prevB.y);
            if (b.color === startBall.color && dist < 90) {
                connected.push(b);
            } else {
                break;
            }
        }
        
        return connected;
    }

    function update(dt) {
        if (isGameOver) return;

        // --- é™æ—¶æ¨¡å¼é€»è¾‘ ---
        if (GameConfig.levelMode === 'time_limit') {
            gameTimeLeft -= dt / 1000;
            if (gameTimeLeft <= 0) {
                gameTimeLeft = 0;
                gameOver(true, 'TIME_UP'); // æ—¶é—´åˆ°ï¼Œæ­£å¸¸ç»“ç®—
                return;
            }
            
            // å€’è®¡æ—¶ UI
            const timerEl = document.getElementById('hud-timer-val');
            if (timerEl) {
                timerEl.innerText = gameTimeLeft.toFixed(1);
                if (gameTimeLeft < 10) timerEl.classList.add('urgent');
                else timerEl.classList.remove('urgent');
            }
        }

        // 1. æ›´æ–° Buff è®¡æ—¶å™¨
        if (activeBuffs.speed > 0) activeBuffs.speed -= dt / 1000;
        if (activeBuffs.slow > 0) activeBuffs.slow -= dt / 1000;
        if (activeBuffs.power > 0) activeBuffs.power -= dt / 1000;
        if (activeBuffs.abyss > 0) activeBuffs.abyss -= dt / 1000;
        updateBuffUI();

        // è®¡ç®—å½“å‰çƒé€Ÿå€ç‡ (ä»… Slow å½±å“çƒé€Ÿ)
        // åŠ¨æ€å¿ƒæµï¼šéšç€åˆ†æ•°å¢åŠ ï¼Œçƒé€Ÿè‡ªç„¶åŠ å¿«
        // æ»¡åˆ† 5000 æ—¶ï¼Œé€Ÿåº¦è¾¾åˆ°åŸºç¡€é€Ÿåº¦çš„ 2.5 å€ (1.0 + 1.5)
        let flowFactor = 1 + (score / GameConfig.maxScore) * 1.5;
        let ballSpeedMult = 1.0 * flowFactor;

        if (activeBuffs.slow > 0) ballSpeedMult *= 0.5;

        // 2. ç”Ÿæˆçƒ (éšæœºæ¨¡å¼ æˆ– é™æ—¶æ¨¡å¼)
        if (GameConfig.levelMode === 'random' || GameConfig.levelMode === 'time_limit') {
            ballTimer += dt;
            if (ballTimer > GameConfig.ballSpawnInterval) {
                balls.push(new Ball());
                ballTimer = 0;
            }
        } else {
            // å›ºå®šæ¨¡å¼èƒœåˆ©æ£€æµ‹ï¼šåœºä¸Šæ— çƒå³å¯ (æ§½ä½é‡Œå‰©ä¸‹çš„ç®—æˆ˜åˆ©å“)
            if (balls.length === 0) {
                gameOver(true, 'CLEARED');
                return;
            }
        }

        // 3. æ›´æ–°çƒä½ç½®
        balls.forEach(b => b.update(ballSpeedMult));
        balls = balls.filter(b => !b.markedForDeletion);
        
        // 4. æŠ“é’©é€»è¾‘
        if (claw.state === 'IDLE') {
            // è‡ªåŠ¨å·¡é€»æ¨¡å¼
            if (GameConfig.controlMode === 'auto') {
                // Speed Buff åŠ é€ŸæŠ“é’©ç§»åŠ¨
                let clawSpeedMult = (activeBuffs.speed > 0) ? 2.0 : 1.0;
                claw.x += GameConfig.clawPatrolSpeed * claw.direction * clawSpeedMult;
                if (claw.x < 50 || claw.x > 700) claw.direction *= -1;
            }
            // PCæ¨¡å¼ï¼šå¹³æ»‘è·Ÿéšé¼ æ ‡
            else if (GameConfig.controlMode === 'mouse') {
                // ç®€å•çš„ç¼“åŠ¨è·Ÿéš (Lerp)
                const speed = 0.2; 
                claw.x += (inputTargetX - claw.x) * speed;
                claw.x = Math.max(50, Math.min(700, claw.x));
            }
            // ç§»åŠ¨ç«¯/Touchæ¨¡å¼ï¼šç›´æ¥ç”± pointermove æ›´æ–°ï¼Œæ­¤å¤„ä»…é™åˆ¶è¾¹ç•Œ
            else {
                claw.x = Math.max(50, Math.min(700, claw.x));
            }
            
            // æ¸¸æˆç»“æŸæ£€æµ‹ï¼šå½“æ§½ä½æ»¡ä¸”æŠ“é’©ç©ºé—²
            if (slots.length >= getMaxSlots()) {
                if (score >= GameConfig.passScore) {
                    gameOver(true, 'PASS');
                } else {
                    gameOver(false, 'FAIL');
                }
            }

        } else if (claw.state === 'DOWN') {
            // Speed Buff åŠ é€Ÿä¸‹è½ (æ‰‹åŠ¨æ¨¡å¼ä¸‹ä¹Ÿèƒ½å—ç›Š)
            let dropSpeedMult = (activeBuffs.speed > 0) ? 1.5 : 1.0;
            claw.y += GameConfig.clawDropSpeed * dropSpeedMult;
            
            // ç¢°æ’æ£€æµ‹
            if (claw.heldBalls.length === 0) {
                // éå†æ‰€æœ‰çƒ
                for (let b of balls) {
                    if (Math.hypot(claw.x - b.x, claw.y - b.y) < 70) {
                        // å‘½ä¸­ï¼
                        
                        // æ·±æ¸Šå·¨çˆªé€»è¾‘ï¼šç©¿é€é”€æ¯
                        if (activeBuffs.abyss > 0) {
                            b.markedForDeletion = true;
                            score += 500; // é”€æ¯å¾—åˆ†
                            updateScoreUI();
                            // ç‰¹æ•ˆ
                            for(let i=0; i<10; i++) particles.push(new Particle(b.x, b.y, b.color));
                            
                            // å…³é”®ï¼šä¸æ”¹å˜çŠ¶æ€ï¼Œè®©çˆªå­ç»§ç»­ä¸‹è½ï¼
                            // ä¸”ä¸ returnï¼Œå…è®¸ä¸€å¸§é”€æ¯å¤šä¸ª
                            continue; 
                        }
                        
                        // æ£€æŸ¥ Power Buff
                        if (activeBuffs.power > 0) {
                            // å¤§åŠ›æ¨¡å¼ï¼šæŠ“ä¸€ä¸²
                            const connected = findConnectedBalls(b);
                            connected.forEach(target => {
                                target.markedForDeletion = true;
                                claw.heldBalls.push({ color: target.color, buff: target.buff });
                            });
                        } else {
                            // æ™®é€šæ¨¡å¼ï¼šæŠ“ä¸€ä¸ª
                            b.markedForDeletion = true;
                            claw.heldBalls.push({ color: b.color, buff: b.buff });
                        }

                        claw.state = 'UP';
                        break;
                    }
                }
            }
            if (claw.y > 1200) claw.state = 'UP';

        } else if (claw.state === 'UP') {
            // Speed Buff åŠ é€Ÿå›æ”¶
            let dropSpeedMult = (activeBuffs.speed > 0) ? 1.5 : 1.0;
            claw.y -= GameConfig.clawDropSpeed * dropSpeedMult;
            
            if (claw.y <= claw.originY) {
                claw.y = claw.originY;
                claw.state = 'IDLE';
                
                // æ”¾å…¥æ§½ä½
                if (claw.heldBalls.length > 0) {
                    claw.heldBalls.forEach(b => slots.push(b));
                    claw.heldBalls = []; // æ¸…ç©ºæŠ“é’©
                    checkMatch();
                }
            }
        }

        // 5. ç²’å­
        particles.forEach(p => p.update());
    }

    function checkMatch() {
        if (slots.length === 0) return;
        
        const lastBall = slots[slots.length - 1];
        const threshold = getMatchThreshold();
        
        // 1. ç»Ÿè®¡æ¯ç§é¢œè‰²çš„ç´¢å¼•
        const colorMap = {}; // { '#FF0000': [0, 2], ... }
        const rainbowIndices = [];
        
        slots.forEach((s, idx) => {
            if (s.buff === BUFF_TYPES.RAINBOW) {
                rainbowIndices.push(idx);
            } else {
                if (!colorMap[s.color]) colorMap[s.color] = [];
                colorMap[s.color].push(idx);
            }
        });
        
        // 2. ç¡®å®šéœ€è¦æ¶ˆé™¤çš„é¢œè‰²ç»„
        // è§„åˆ™ï¼šå¦‚æœä¸è¿ç»­ä¹Ÿèƒ½æ¶ˆï¼Œé‚£ä¹ˆä¼˜å…ˆåŒ¹é… lastBall ç›¸å…³çš„é¢œè‰²
        // å¦‚æœ lastBall æ˜¯ Rainbowï¼Œåˆ™åŒ¹é…æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„é¢œè‰²ç»„
        
        let matchedColors = new Set();
        
        if (lastBall.buff === BUFF_TYPES.RAINBOW) {
            // æ£€æŸ¥æ‰€æœ‰é¢œè‰²
            for (let color in colorMap) {
                const count = colorMap[color].length;
                if (count + rainbowIndices.length >= threshold) {
                    matchedColors.add(color);
                }
            }
            // å¦‚æœæ²¡æœ‰ä»»ä½•æ™®é€šé¢œè‰²æ»¡è¶³æ¡ä»¶ï¼Œä½† Rainbow æœ¬èº«å¤Ÿå¤šï¼Ÿ(æ¯”å¦‚ 3 ä¸ª Rainbow)
            if (matchedColors.size === 0 && rainbowIndices.length >= threshold) {
                // ç‰¹æ®Šæ ‡è®°ï¼šæ¶ˆé™¤ Rainbow è‡ªèº«
                matchedColors.add('RAINBOW_ONLY');
            }
        } else {
            // lastBall æ˜¯æ™®é€šè‰²
            const color = lastBall.color;
            const count = (colorMap[color] ? colorMap[color].length : 0);
            if (count + rainbowIndices.length >= threshold) {
                matchedColors.add(color);
            }
        }
        
        if (matchedColors.size === 0) return;
        
        // 3. æ„å»ºæ¶ˆé™¤ç´¢å¼•åˆ—è¡¨
        let removeIndices = new Set();
        let usedRainbows = false;
        
        if (matchedColors.has('RAINBOW_ONLY')) {
            rainbowIndices.forEach(idx => removeIndices.add(idx));
            usedRainbows = true;
        } else {
            matchedColors.forEach(color => {
                // æ·»åŠ è¯¥é¢œè‰²çš„æ‰€æœ‰çƒ
                if (colorMap[color]) {
                    colorMap[color].forEach(idx => removeIndices.add(idx));
                }
                // åªè¦æœ‰ä»»æ„é¢œè‰²åŒ¹é…ï¼ŒRainbow å°±è¢«å¾ç”¨
                usedRainbows = true;
            });
            
            if (usedRainbows) {
                rainbowIndices.forEach(idx => removeIndices.add(idx));
            }
        }
        
        // 4. è§¦å‘æ¶ˆé™¤
        const chain = Array.from(removeIndices);
        
        // è§¦å‘æ¶ˆé™¤
        let removedBuffs = [];
        let hasBomb = false;
        let hasMythril = false;
        let mythrilCount = 0;
        let baseColor = lastBall.color; // ç”¨äºç²’å­ç‰¹æ•ˆé¢œè‰²
        
        chain.forEach(idx => {
            // ç‰¹æ•ˆ
            // é‡æ–°è®¡ç®—ä½ç½®é€»è¾‘ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªç¡®ä¿å¤§æ¦‚ä½ç½®
            // ä¸ºäº†å‡†ç¡®ï¼Œåº”è¯¥æ ¹æ® idx ç®—ä½ç½®ï¼Œä½†è¿™é‡Œæš‚ç”¨ä¸­å¿ƒç‚¹ä»£æ›¿æˆ–ç®€åŒ–
            const maxSlots = getMaxSlots();
            const spacing = (maxSlots > 5) ? 80 : 125;
            const startX = (maxSlots > 5) ? 35 : 75;
            const bx = startX + (idx % maxSlots) * spacing;
            const by = 180 + Math.floor(idx / maxSlots) * 110; 
            
            for(let i=0; i<20; i++) particles.push(new Particle(bx, by, slots[idx].color));
            
            const buff = slots[idx].buff;
            if (buff && buff !== BUFF_TYPES.NONE) {
                removedBuffs.push(buff);
                if (buff === BUFF_TYPES.BOMB) hasBomb = true;
                if (buff === BUFF_TYPES.MYTHRIL) { hasMythril = true; mythrilCount++; }
            }
        });

        // çœŸæ­£ç§»é™¤ (åˆ©ç”¨ filter)
        const removeSet = new Set(chain);
        slots = slots.filter((_, i) => !removeSet.has(i));
        
        // åŠ åˆ†
        let basePoints = 100 * chain.length;
        if (hasMythril) basePoints += 5000 * mythrilCount; // ç§˜é“¶åŠ åˆ†
        
        score += basePoints;
        
        // ç‚¸å¼¹é€»è¾‘ï¼šæ¸…ç©ºå‰©ä½™æ§½ä½
        if (hasBomb) {
            // ç‰¹æ•ˆ
            slots.forEach(() => {
                for(let i=0; i<10; i++) particles.push(new Particle(375, 250, '#000'));
            });
            slots = []; // æ¸…ç©ºï¼
        }

        // é™æ—¶æ¨¡å¼éš¾åº¦æ£€æµ‹
        if (GameConfig.levelMode === 'time_limit') {
            checkDifficultyUp();
        }
        
        updateScoreUI();

        // æ¿€æ´» Buff
        removedBuffs.forEach(buff => {
            if (buff === BUFF_TYPES.MYSTERY) {
                blindBoxCount++;
                updateBlindBoxUI();
            } else if (buff === BUFF_TYPES.SPEED) {
                activeBuffs.speed = GameConfig.buffDuration;
                activeBuffs.slow = 0; // äº’æ–¥
            } else if (buff === BUFF_TYPES.SLOW) {
                activeBuffs.slow = GameConfig.buffDuration;
                activeBuffs.speed = 0; // äº’æ–¥
            } else if (buff === BUFF_TYPES.POWER) {
                activeBuffs.power = GameConfig.buffDuration;
            } else if (buff === BUFF_TYPES.ABYSS) {
                activeBuffs.abyss = GameConfig.buffDuration;
            }
        });
    }

    function draw() {
        ctx.clearRect(0,0,750,1334);

        // è½¨é“
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 20;
        for(let i=0; i<pathPoints.length; i++) {
            const p = pathPoints[i];
            if(i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // çƒä¸ç²’å­
        balls.forEach(b => b.draw(ctx));
        particles.forEach(p => p.draw(ctx));

        // æ§½ä½ (ç§»åˆ°æŠ“é’©ä¹‹å‰ç»˜åˆ¶ï¼Œé˜²æ­¢é®æŒ¡)
        // åŠ¨æ€è®¡ç®—å¸ƒå±€
        const maxSlots = getMaxSlots();
        const slotCount = Math.max(maxSlots, slots.length);
        
        // åŠ¨æ€è°ƒæ•´èµ·å§‹ä½ç½®å’Œé—´è·ä»¥å±…ä¸­
        let slotW = 100; // æ¡†å¤§å°
        let spacing = (maxSlots > 5) ? 80 : 125;
        let startX = (750 - (maxSlots * spacing)) / 2 + (spacing/2) - 50; 
        
        if (maxSlots > 5) startX = 35; 
        else startX = 75; 
        
        // æ•´ä½“ä¸‹ç§» 150px ä»¥é¿å¼€é¡¶éƒ¨ HUD (åŸ 30 -> 180)
        const slotBaseY = 180;

        for(let i=0; i<slotCount; i++) {
            // è®¡ç®—ä½ç½®
            const bx = startX + (i % maxSlots) * spacing;
            const by = slotBaseY + Math.floor(i / maxSlots) * 110; 
            
            // åªç”»æœ€å¤§å®¹é‡å†…çš„èƒŒæ™¯æ¡†
            if (i < maxSlots) {
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2; // ä¿®å¤ï¼šçº¿æ¡å˜ç»†
                ctx.strokeRect(bx, slotBaseY, (maxSlots>5 ? 70 : 100), 100); 
            }
            
            if (slots[i]) {
                // çƒå¿ƒ
                let cx = bx + (maxSlots>5 ? 35 : 50);
                let cy = by + 50;
                let r = (maxSlots>5 ? 30 : 40); 
                
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.fillStyle = slots[i].color; ctx.fill();
                
                // Buff æ ‡è®°
                if (slots[i].buff && slots[i].buff !== 'none') {
                    ctx.font = (maxSlots>5 ? '16px' : '20px') + ' Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let s = '';
                    switch(slots[i].buff) {
                        case BUFF_TYPES.MYSTERY: s='â“'; break;
                        case BUFF_TYPES.SPEED: s='âš¡'; break;
                        case BUFF_TYPES.SLOW: s='ğŸ¢'; break;
                        case BUFF_TYPES.POWER: s='ğŸ’ª'; break;
                        case BUFF_TYPES.ABYSS: s='ğŸ¦–'; break;
                        case BUFF_TYPES.MYTHRIL: s='ğŸ’'; break;
                        case BUFF_TYPES.RAINBOW: s='ğŸŒˆ'; break;
                        case BUFF_TYPES.BOMB: s='ğŸ’£'; break;
                    }
                    
                    // æè¾¹
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    ctx.strokeText(s, cx, cy);
                    
                    ctx.fillStyle = '#fff';
                    ctx.fillText(s, cx, cy);
                }
            }
        }

        // æŠ“é’©ç»³å­
        ctx.beginPath();
        // ä»æ§½ä½åº•ç«¯å¼€å§‹ (slotBaseY=180, height=100, so ~280-300)
        ctx.moveTo(claw.x, 290); 
        ctx.lineTo(claw.x, claw.y);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 5;
        ctx.stroke();
        
        // æŠ“é’©å¤´ä¸æŒçƒ
        ctx.save();
        ctx.translate(claw.x, claw.y);
        
        // å¦‚æœæŠ“ç€çƒ
        if (claw.heldBalls.length > 0) {
            // ç”»ç¬¬ä¸€ä¸ªçƒä½œä¸ºä»£è¡¨ï¼Œæˆ–è€…ç”»ä¸€ä¸²ï¼Ÿç”»ä¸€ä¸²æ¯”è¾ƒé…·
            claw.heldBalls.forEach((b, i) => {
                ctx.beginPath(); 
                ctx.arc(0, 40 + i*60, 40, 0, Math.PI*2); // å‚ç›´ä¸²è”
                ctx.fillStyle = b.color; 
                ctx.fill();
            });
        }
        
        // é’©çˆªä¸»ä½“
        ctx.fillStyle = '#ffcc80';
        ctx.fillRect(-30, 0, 60, 40);
        
        // Power Buff è§†è§‰ç‰¹æ•ˆ (æŠ“é’©å‘å…‰)
        if (activeBuffs.power > 0) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.strokeRect(-32, -2, 64, 44);
        }
        
        ctx.restore();
    }

    function gameOver(success, reason) {
        isGameOver = true;
        const modal = document.getElementById('game-over-modal');
        const title = document.getElementById('modal-title');
        const desc = document.getElementById('modal-desc');
        const boxArea = document.getElementById('blind-box-area');
        
        modal.style.display = 'flex';
        
        // é™æ—¶æ¨¡å¼ç‰¹æ®Šç»“ç®—
        if (GameConfig.levelMode === 'time_limit') {
            title.innerText = (reason === 'TIME_UP') ? "â° æ—¶é—´åˆ°ï¼" : "ğŸ’” æ§½ä½å·²æ»¡";
            title.style.color = (reason === 'TIME_UP') ? "#ffd700" : "#ff4444";
            
            // æ›´æ–°æœ€é«˜åˆ†
            if (score > highScoreTimeLimit) {
                highScoreTimeLimit = score;
                localStorage.setItem('claw_machine_highscore_time', highScoreTimeLimit);
                desc.innerHTML = `æœ€ç»ˆå¾—åˆ†: <span style="color:#fff;font-size:32px">${score}</span><br><span style="color:#ff9a9e;font-size:16px">ğŸ”¥ æ–°çºªå½•ï¼(æ—§: ${highScoreTimeLimit})</span>`;
            } else {
                desc.innerHTML = `æœ€ç»ˆå¾—åˆ†: ${score}<br><span style="color:#aaa;font-size:16px">å†å²æœ€é«˜: ${highScoreTimeLimit}</span>`;
            }
            
            boxArea.style.display = 'none'; // éšè—ç›²ç›’
            return;
        }
        
        if (success) {
            title.innerText = reason === 'FULL' ? "ğŸ‰ å®Œç¾é€šå…³ï¼" : "âœ… æŒ‘æˆ˜æˆåŠŸï¼";
            title.style.color = "#00f2fe";
        } else {
            title.innerText = "ğŸ’” æ¸¸æˆç»“æŸ";
            title.style.color = "#ff4444";
        }
        
        desc.innerText = `æœ€ç»ˆå¾—åˆ†: ${score}`;
        
        // ç»“ç®—ç›²ç›’
        if (blindBoxCount > 0) {
            boxArea.style.display = 'block';
            document.getElementById('box-count').innerText = blindBoxCount;
            const resContainer = document.getElementById('blind-box-result');
            resContainer.innerHTML = '';
            
            // å¢å¼ºç‰ˆå¼€ç›²ç›’åŠ¨ç”»é€»è¾‘
            const rewards = ['ğŸ’', 'ğŸ¬', 'ğŸ§¸', 'ğŸˆ', 'ğŸ’°', 'ğŸ', 'âœ¨', 'ğŸ‘‘', 'ğŸ¦„'];
            
            for(let i=0; i<blindBoxCount; i++) {
                // 1. åˆ›å»ºå®¹å™¨ç»“æ„
                const wrapper = document.createElement('div');
                wrapper.className = 'blind-box-wrapper';
                
                const ball = document.createElement('div');
                ball.className = 'blind-box-ball';
                ball.innerText = 'â“';
                
                const prize = document.createElement('div');
                prize.className = 'blind-box-prize';
                prize.innerText = rewards[Math.floor(Math.random()*rewards.length)];
                
                wrapper.appendChild(prize); // å¥–å“åœ¨ä¸‹
                wrapper.appendChild(ball);  // çƒåœ¨ä¸Š
                
                // å»¶è¿Ÿæ·»åŠ åˆ° DOMï¼Œåˆ¶é€ é€ä¸ªå…¥åœºæ„Ÿ
                setTimeout(() => {
                    resContainer.appendChild(wrapper);
                    
                    // 2. è§¦å‘éœ‡åŠ¨
                    ball.classList.add('shaking');
                    
                    // 3. éœ‡åŠ¨åå¼€å¯ (å»¶è¿Ÿ 600ms)
                    setTimeout(() => {
                        ball.classList.remove('shaking');
                        ball.classList.add('opened');
                        prize.classList.add('revealed');
                    }, 600);
                    
                }, i * 400); // é—´éš”åŠ å¤§ï¼Œè®©æ¯ä¸ªçƒéƒ½æœ‰å•ç‹¬çš„å…³æ³¨æ—¶åˆ»
            }
        } else {
            boxArea.style.display = 'none';
        }
    }

    function resetGame() {
        isGameOver = false;
        score = 0;
        slots = [];
        balls = []; // initPathä¼šå†æ¬¡æ¸…ç©ºï¼Œä½†è¿™é‡Œæ˜¾å¼ä¸€ç‚¹
        blindBoxCount = 0;
        activeBuffs = { speed:0, slow:0, power:0 };
        claw.state = 'IDLE';
        claw.heldBalls = [];
        
        // é™æ—¶æ¨¡å¼é‡ç½®
        if (GameConfig.levelMode === 'time_limit') {
            gameTimeLeft = GameConfig.timeLimit;
            currentDiffLevel = 0;
            GameConfig.ballSpeed = 0.5; // é‡ç½®éš¾åº¦
            GameConfig.ballSpawnInterval = 500;
            
            // UI åˆ‡æ¢
            document.getElementById('hud-timer-container').style.display = 'block';
            document.querySelector('.hud-blind-box').style.display = 'none';
            document.querySelectorAll('.marker-default').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.marker-time').forEach(el => el.style.display = 'block');
        } else {
            // æ™®é€šæ¨¡å¼é‡ç½®
            document.getElementById('hud-timer-container').style.display = 'none';
            document.querySelector('.hud-blind-box').style.display = 'flex';
            document.querySelectorAll('.marker-default').forEach(el => el.style.display = 'block');
            document.querySelectorAll('.marker-time').forEach(el => el.style.display = 'none');
        }
        
        document.getElementById('game-over-modal').style.display = 'none';
        
        updateScoreUI();
        updateBuffUI();
        updateBlindBoxUI();
        initPath();
        
        // é‡æ–°å¯åŠ¨å¾ªç¯ (å¦‚æœä¹‹å‰åœæ­¢äº†çš„è¯ï¼Œä½†æˆ‘ä»¬å…¶å®æ²¡åœæ­¢RAFï¼Œåªæ˜¯returnäº†)
        // updateä¸­åŠ äº† isGameOver æ£€æŸ¥ï¼Œæ‰€ä»¥åªéœ€è¦é‡ç½®å˜é‡å³å¯
    }

    function loop(timestamp) {
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        
        // é™åˆ¶æœ€å¤§å¸§é—´éš”ï¼Œé˜²æ­¢åˆ‡æ¢åå°å›æ¥åé£é€Ÿè¿è¡Œ
        const safeDt = Math.min(dt, 50);
        
        update(safeDt);
        draw();
        
        requestAnimationFrame(loop);
    }

    // ç»‘å®šUIäº‹ä»¶
    function bindDebugPanel() {
        const bind = (id, key, needsPathUpdate = false) => {
            const input = document.getElementById('inp-' + id);
            const display = document.getElementById('val-' + id);
            
            if (!display) {
                input.addEventListener('change', (e) => {
                    GameConfig[key] = e.target.value;
                    if (needsPathUpdate) initPath();
                });
                return;
            }
            
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                GameConfig[key] = val;
                display.innerText = val;
                if (needsPathUpdate) initPath();
            });
        };

        bind('speed', 'ballSpeed');
        bind('spawn', 'ballSpawnInterval');
        bind('trackShape', 'trackShape', true);
        
        // SlotLimit ç‰¹æ®Šå¤„ç†ï¼šinputæ›´æ–°æ˜¾ç¤ºï¼Œchangeæ›´æ–°é…ç½®å¹¶é‡ç½®
        const sInp = document.getElementById('inp-slotLimit');
        const sVal = document.getElementById('val-slotLimit');
        sInp.addEventListener('input', (e) => {
            sVal.innerText = e.target.value;
        });
        sInp.addEventListener('change', (e) => {
             GameConfig.slotLimit = parseInt(e.target.value);
             resetGame();
        });
        
            // ç»‘å®šæ–°æ¨¡å¼æ§ä»¶ (å˜æ›´æ—¶é‡ç½®æ¸¸æˆ)
        ['matchMode', 'levelMode', 'controlMode'].forEach(key => {
            document.getElementById('inp-' + key).addEventListener('change', (e) => {
                GameConfig[key] = e.target.value;
                
                // ç‰¹æ®Šè”åŠ¨ï¼šmatchMode å½±å“ slotLimit
                if (key === 'matchMode') {
                    const slotGroup = document.getElementById('group-slotLimit');
                    const slotInp = document.getElementById('inp-slotLimit');
                    const slotVal = document.getElementById('val-slotLimit');
                    
                    if (GameConfig.matchMode === 'match3') {
                        slotGroup.style.display = 'block';
                        GameConfig.slotLimit = parseInt(slotInp.value); // æ¢å¤ä¹‹å‰çš„è®¾å®š
                    } else {
                        slotGroup.style.display = 'none';
                        GameConfig.slotLimit = 5;
                    }
                }
                
                resetGame();
            });
        });
        
        // Debug å¢å¼ºç»‘å®š
        document.getElementById('inp-nextBuff').addEventListener('change', (e) => {
            debugNextBuff = e.target.value;
        });
        
        const colInp = document.getElementById('inp-colorCount');
        const colVal = document.getElementById('val-colorCount');
        colInp.addEventListener('input', (e) => {
            colVal.innerText = e.target.value;
            GameConfig.activeColorCount = parseInt(e.target.value);
            // è¿™é‡Œä¸éœ€è¦é‡ç½®æ¸¸æˆï¼Œåªä¼šå½±å“æ–°ç”Ÿæˆçš„çƒ
        });
    }

    // äº¤äº’ - æ–°æ¨¡å¼ï¼šåŒºåˆ† PC (mouse) å’Œ Mobile (touch)
    canvas.addEventListener('pointermove', (e) => {
        if (claw.state === 'IDLE' && !isGameOver) {
            // PCæ¨¡å¼ï¼šé¼ æ ‡æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆå¹³æ»‘è·Ÿéšï¼‰
            if (GameConfig.controlMode === 'mouse') {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                inputTargetX = (e.clientX - rect.left) * scaleX;
                // è¾¹ç•Œé™åˆ¶åœ¨ update ä¸­å¤„ç†
            }
            // ç§»åŠ¨ç«¯æ¨¡å¼ï¼šæ‹–æ‹½æ—¶ç›´æ¥ç§»åŠ¨ï¼ˆ1:1è·Ÿæ‰‹ï¼‰
            else if (GameConfig.controlMode === 'touch' && isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                let x = (e.clientX - rect.left) * scaleX;
                claw.x = x; 
            }
        }
    });

    canvas.addEventListener('pointerdown', (e) => {
        if (isGameOver) return;
        if (claw.state === 'IDLE') {
            if (slots.length < getMaxSlots()) {
                
                // PCæ¨¡å¼ æˆ– è‡ªåŠ¨æ¨¡å¼ï¼šç‚¹å‡»ç›´æ¥ä¸‹è½
                if (GameConfig.controlMode === 'mouse' || GameConfig.controlMode === 'auto') {
                     claw.state = 'DOWN';
                }
                // ç§»åŠ¨ç«¯æ¨¡å¼ï¼šå¼€å§‹æ‹–æ‹½
                else if (GameConfig.controlMode === 'touch') {
                    isDragging = true;
                    canvas.setPointerCapture(e.pointerId); // é”å®šæŒ‡é’ˆ
                    
                    // ç«‹å³æ›´æ–°ä½ç½®
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    let x = (e.clientX - rect.left) * scaleX;
                    claw.x = x;
                }
            }
        }
    });

    canvas.addEventListener('pointerup', (e) => {
        // ç§»åŠ¨ç«¯æ¨¡å¼ï¼šæ¾æ‰‹ä¸‹è½
        if (GameConfig.controlMode === 'touch' && isDragging) {
            isDragging = false;
            canvas.releasePointerCapture(e.pointerId);
            
            if (!isGameOver && claw.state === 'IDLE' && slots.length < getMaxSlots()) {
                claw.state = 'DOWN';
            }
        }
    });

    // å¯åŠ¨
    bindDebugPanel();
    initPath();
    requestAnimationFrame(loop);

</script>
</body>
</html>