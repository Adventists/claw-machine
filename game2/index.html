<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¥–ç›æŠ“æŠ“ä¹ - Buffå¢å¼ºç‰ˆ</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #222; 
            height: 100vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-family: "Microsoft YaHei", sans-serif; 
            overflow: hidden; 
            color: #fff;
        }
        
        /* ä¸»å¸ƒå±€å®¹å™¨ */
        #main-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        /* æ¸¸æˆå®¹å™¨ */
        #game-wrapper {
            position: relative;
            height: 95vh;
            aspect-ratio: 750/1334;
            background: linear-gradient(180deg, #fffbf0 0%, #e6f7ff 100%);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }

        canvas { width: 100%; height: 100%; display: block; }

        /* ä¾§è¾¹æ  */
        #side-panel {
            width: 260px;
            background: #333;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 90vh;
        }

        .panel-section {
            background: #444;
            padding: 15px;
            border-radius: 8px;
        }

        h3 { margin: 0 0 10px 0; color: #ff8fab; font-size: 16px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        
        /* è¿›åº¦æ¡æ ·å¼ */
        .progress-container {
            width: 100%;
            height: 24px;
            background: #222;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 2px solid #555;
            margin-top: 5px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s;
        }
        .progress-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ffff00;
            z-index: 2;
        }
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
        }
        
        /* Buff çŠ¶æ€å±•ç¤º */
        .buff-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            background: #555;
            padding: 8px;
            border-radius: 6px;
            opacity: 0.5;
            transition: all 0.3s;
        }
        .buff-item.active {
            opacity: 1;
            background: #666;
            border: 1px solid #ff8fab;
        }
        .buff-icon { font-size: 20px; width: 30px; text-align: center; }
        .buff-info { flex: 1; }
        .buff-timer { font-weight: bold; color: #ffd700; }

        /* è°ƒè¯•æ§åˆ¶é¡¹ */
        .control-group { margin-bottom: 8px; font-size: 12px; }
        .control-group label { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .control-group input { width: 100%; cursor: pointer; }
        .value-display { color: #ff8fab; font-weight: bold; }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        #game-over-modal h2 { font-size: 36px; margin-bottom: 10px; color: #ff8fab; }
        #game-over-modal p { font-size: 18px; color: #ccc; margin-bottom: 20px; }
        button.restart-btn {
            padding: 10px 30px;
            font-size: 20px;
            background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #333;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 154, 158, 0.4);
        }

        /* ç›²ç›’å±•ç¤º */
        #blind-box-result {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .box-opened {
            width: 50px; height: 50px;
            background: #fff;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-weight: bold;
            animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes pop {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

<div id="main-container">
    <!-- ä¾§è¾¹ä¿¡æ¯æ  -->
    <div id="side-panel">
        <div class="panel-section">
            <h3>å½“å‰åˆ†æ•°</h3>
            <div style="text-align: center; font-size: 28px; font-weight: bold; color: #4facfe;" id="score-text">0</div>
            <div class="progress-container">
                <div class="progress-fill" id="progress-fill"></div>
                <!-- 2000åˆ†æ ‡è®° (40%) -->
                <div class="progress-marker" style="left: 40%; background: #ff9a9e;" title="é€šå…³çº¿"></div>
            </div>
            <div class="progress-label">
                <span>0</span>
                <span style="color:#ff9a9e">2000(é€šå…³)</span>
                <span>5000(æ»¡çº§)</span>
            </div>
        </div>

        <div class="panel-section">
            <h3>Buff çŠ¶æ€</h3>
            <div id="buff-list">
                <div class="buff-item" id="buff-speed">
                    <span class="buff-icon">âš¡</span>
                    <div class="buff-info">æ€¥é€Ÿç‹‚é£™</div>
                    <span class="buff-timer" id="timer-speed">--</span>
                </div>
                <div class="buff-item" id="buff-slow">
                    <span class="buff-icon">ğŸ¢</span>
                    <div class="buff-info">æ—¶é—´å†»ç»“</div>
                    <span class="buff-timer" id="timer-slow">--</span>
                </div>
                <div class="buff-item" id="buff-power">
                    <span class="buff-icon">ğŸ’ª</span>
                    <div class="buff-info">å¤§åŠ›ç¥çˆª</div>
                    <span class="buff-timer" id="timer-power">--</span>
                </div>
                <!-- æ–°å¢ï¼šç›²ç›’è®¡æ•°æ˜¾ç¤º -->
                <div class="buff-item" style="opacity: 1; border: 1px solid #aaa;">
                    <span class="buff-icon">â“</span>
                    <div class="buff-info">å·²æ”¶é›†ç›²ç›’</div>
                    <span class="buff-timer" id="blind-box-count-ui" style="color: #ff9a9e;">0</span>
                </div>
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #888;">
                <p>â“ ç›²ç›’: ç»“ç®—æ—¶å¼€å¯</p>
                <p>âš¡ åŠ é€Ÿ: çƒé€Ÿ x2 (5s)</p>
                <p>ğŸ¢ å‡é€Ÿ: çƒé€Ÿ x0.5 (5s)</p>
                <p>ğŸ’ª å¤§åŠ›: è¿æŠ“åŒè‰²çƒ (5s)</p>
            </div>
        </div>

        <div class="panel-section" id="debug-controls">
            <h3>å¼€å‘è€…æ§åˆ¶å°</h3>
            <div class="control-group">
                <label>è½¨é“å½¢çŠ¶</label>
                <select id="inp-trackShape" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="sine">æ³¢æµª (ç®€å•)</option>
                    <option value="spiral">èºæ—‹ (æŒ‘æˆ˜)</option>
                    <option value="circle">å¤§å›ç¯</option>
                    <option value="infinity" selected>æ— é™ (âˆ)</option>
                    <option value="heart">çˆ±å¿ƒ</option>
                </select>
            </div>
            <div class="control-group">
                <label>åŸºç¡€çƒé€Ÿ <span id="val-speed" class="value-display">0.5</span></label>
                <input type="range" id="inp-speed" min="0.5" max="5" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>ç”Ÿæˆé—´éš” <span id="val-spawn" class="value-display">500</span></label>
                <input type="range" id="inp-spawn" min="500" max="3000" step="100" value="500">
            </div>
            
            <div style="border-top: 1px solid #555; margin: 10px 0;"></div>

            <div class="control-group">
                <label>æ¶ˆé™¤æ¨¡å¼</label>
                <select id="inp-matchMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="match2">äºŒæ¶ˆ (5æ§½)</option>
                    <option value="match3">ä¸‰æ¶ˆ (å¯é…)</option>
                </select>
            </div>
            <div class="control-group" id="group-slotLimit" style="display:none;">
                <label>æ§½ä½ä¸Šé™ <span id="val-slotLimit" class="value-display">9</span></label>
                <input type="range" id="inp-slotLimit" min="7" max="9" step="1" value="9">
            </div>
            <div class="control-group">
                <label>å…³å¡æ¨¡å¼</label>
                <select id="inp-levelMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="random">éšæœºç”Ÿæˆ</option>
                    <option value="fixed">å›ºå®šå…³å¡</option>
                </select>
            </div>
            <div class="control-group">
                <label>æ“ä½œæ¨¡å¼</label>
                <select id="inp-controlMode" style="width:100%; margin-top:2px; padding:4px; border-radius:4px; border:none; background:#222; color:white;">
                    <option value="auto">è‡ªåŠ¨æ‘†åŠ¨</option>
                    <option value="manual">é¼ æ ‡æ§åˆ¶</option>
                </select>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»åŒºåŸŸ -->
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="750" height="1334"></canvas>
        
        <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
        <div id="game-over-modal">
            <h2 id="modal-title">æ¸¸æˆç»“æŸ</h2>
            <p id="modal-desc">å¾—åˆ†: 100</p>
            <div id="blind-box-area" style="display:none;">
                <p style="font-size:14px; color:#ff9a9e;">å¼€å¯äº† <span id="box-count">0</span> ä¸ªç›²ç›’!</p>
                <div id="blind-box-result"></div>
            </div>
            <button class="restart-btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>
</div>

<script>
    /**
     * æ¸¸æˆé…ç½®
     */
    const GameConfig = {
        ballSpeed: 0.5,
        ballSpawnInterval: 500,
        clawPatrolSpeed: 8,
        clawDropSpeed: 25,
        
        trackBaseY: 900,
        trackAmplitude: 120,
        trackFrequency: 0.01,
        trackShape: 'infinity',
        
        colors: ['#FF9AA2', '#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7', '#C7CEEA'],
        
        // åˆ†æ•°ç³»ç»Ÿ
        maxScore: 5000,
        passScore: 2000,
        
        // Buff å‚æ•°
        buffProbability: 0.15, // 15% æ¦‚ç‡å‡º Buff
        buffDuration: 5.0,      // 5ç§’
        
        // æ–°å¢æ¨¡å¼é…ç½®
        matchMode: 'match2',   // match2 | match3
        slotLimit: 5,          // 5 | 7-9
        levelMode: 'random',   // random | fixed
        controlMode: 'auto',   // auto | manual
        fixedBallCount: 30     // å›ºå®šå…³å¡åˆå§‹çƒæ•°
    };

    // è¾…åŠ©è·å–å½“å‰æ¨¡å¼å‚æ•°
    const getMatchThreshold = () => GameConfig.matchMode === 'match3' ? 3 : 2;
    const getMaxSlots = () => GameConfig.slotLimit;

    const BUFF_TYPES = {
        NONE: 'none',
        MYSTERY: 'mystery', // â“
        SPEED: 'speed',     // âš¡
        SLOW: 'slow',       // ğŸ¢
        POWER: 'power'      // ğŸ’ª
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // å…¨å±€çŠ¶æ€
    let score = 0;
    let lastTime = 0;
    let ballTimer = 0;
    let pathPoints = []; 
    let balls = [];
    let slots = [];
    let particles = [];
    let isGameOver = false;
    let blindBoxCount = 0;

    // Buff çŠ¶æ€ (å‰©ä½™ç§’æ•°)
    let activeBuffs = {
        speed: 0,
        slow: 0,
        power: 0
    };
    
    // æŠ“é’©å¯¹è±¡
    const claw = {
        x: 375, y: 200, originY: 200,
        state: 'IDLE', direction: 1, 
        heldBalls: [] // æ”¹ä¸ºæ•°ç»„ï¼Œæ”¯æŒæŠ“å¤šä¸ª
    };

    // --- UI æ§åˆ¶ ---
    function updateScoreUI() {
        document.getElementById('score-text').innerText = score;
        const pct = Math.min(100, (score / GameConfig.maxScore) * 100);
        document.getElementById('progress-fill').style.width = pct + '%';
        
        // å®æ—¶æ£€æŸ¥æ»¡çº§
        if (score >= GameConfig.maxScore && !isGameOver) {
            gameOver(true, 'FULL');
        }
    }

    function updateBuffUI() {
        // Helper to update specific buff item
        const updateItem = (type, timer) => {
            const el = document.getElementById('buff-' + type);
            const timerEl = document.getElementById('timer-' + type);
            if (timer > 0) {
                el.classList.add('active');
                timerEl.innerText = timer.toFixed(1) + 's';
            } else {
                el.classList.remove('active');
                timerEl.innerText = '--';
            }
        };

        updateItem('speed', activeBuffs.speed);
        updateItem('slow', activeBuffs.slow);
        updateItem('power', activeBuffs.power);
    }

    function updateBlindBoxUI() {
        const el = document.getElementById('blind-box-count-ui');
        if (el) el.innerText = blindBoxCount;
    }

    // --- æ¸¸æˆé€»è¾‘ç±» ---

    class Ball {
        constructor() {
            this.pathIndex = 0;
            this.color = GameConfig.colors[Math.floor(Math.random() * GameConfig.colors.length)];
            this.markedForDeletion = false;
            
            // éšæœºåˆ†é… Buff
            this.buff = BUFF_TYPES.NONE;
            if (Math.random() < GameConfig.buffProbability) {
                const types = [BUFF_TYPES.MYSTERY, BUFF_TYPES.SPEED, BUFF_TYPES.SLOW, BUFF_TYPES.POWER];
                this.buff = types[Math.floor(Math.random() * types.length)];
            }
            
            this.updatePos();
        }

        updatePos() {
            const idx = Math.floor(this.pathIndex);
            if (idx < pathPoints.length) {
                this.x = pathPoints[idx].x;
                this.y = pathPoints[idx].y;
            } else {
                if (GameConfig.levelMode === 'fixed') {
                    // å›ºå®šæ¨¡å¼ï¼šå¾ªç¯
                    this.pathIndex = 0;
                    this.updatePos();
                } else {
                    // éšæœºæ¨¡å¼ï¼šé”€æ¯
                    this.markedForDeletion = true;
                }
            }
        }

        update(dtMultiplier) {
            // åº”ç”¨å…¨å±€é€Ÿåº¦å€ç‡ (ä»… Slow Buff å½±å“çƒé€Ÿï¼ŒSpeed Buff ç°åœ¨å½±å“æŠ“é’©)
            // å¦‚æœ dtMultiplier æ˜¯ä» update() ä¼ å…¥çš„ï¼Œéœ€è¦ç¡®è®¤å…¶é€»è¾‘ã€‚
            // ä¹‹å‰çš„ update() é€»è¾‘æ˜¯ï¼šå¦‚æœæœ‰ speed buff, mult=2; slow buff, mult=0.5
            // æˆ‘ä»¬å°†åœ¨å¤–éƒ¨ update() ä¿®æ”¹æ­¤é€»è¾‘ï¼Œè¿™é‡Œä¿æŒæ¥æ”¶å€ç‡å‚æ•°
            this.pathIndex += GameConfig.ballSpeed * dtMultiplier;
            this.updatePos();
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 40, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // ç»˜åˆ¶ Buff å›¾æ ‡
            if (this.buff !== BUFF_TYPES.NONE) {
                // ç§»é™¤é®ç½©ï¼Œç›´æ¥ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let symbol = '';
                switch(this.buff) {
                    case BUFF_TYPES.MYSTERY: symbol = 'â“'; break;
                    case BUFF_TYPES.SPEED: symbol = 'âš¡'; break;
                    case BUFF_TYPES.SLOW: symbol = 'ğŸ¢'; break;
                    case BUFF_TYPES.POWER: symbol = 'ğŸ’ª'; break;
                }
                ctx.fillText(symbol, this.x, this.y + 2); // å¾®è°ƒå‚ç›´ä½ç½®
            }
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random()-0.5)*15;
            this.vy = (Math.random()-0.5)*15;
            this.life = 1;
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
        draw(ctx) {
            if(this.life<=0) return;
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // --- æ ¸å¿ƒåŠŸèƒ½ ---

    function initPath() {
        pathPoints = [];
        balls = []; // æ¯æ¬¡é‡ç½®è·¯å¾„æ—¶æ¸…ç©ºçƒ
        
        let shape = GameConfig.trackShape;
        let cx = 375, cy = 700;
        
        if (shape === 'sine') {
            for (let x = -100; x <= 850; x += 5) {
                let y = GameConfig.trackBaseY 
                      + Math.sin(x * GameConfig.trackFrequency) * GameConfig.trackAmplitude 
                      + (x * 0.1);
                pathPoints.push({x, y});
            }
        } 
        else if (shape === 'spiral') {
            cy = 600;
            let radius = 10;
            let angle = 0;
            for (let i = 0; i < 600; i++) {
                angle += 0.1; radius += 0.5;
                let x = cx + radius * Math.cos(angle);
                let y = cy + radius * Math.sin(angle);
                pathPoints.push({x, y});
            }
        }
        else if (shape === 'circle') {
             const r = 300;
             for (let i = 0; i < 360; i++) {
                 let rad = (i - 90) * (Math.PI / 180); 
                 let x = cx + r * Math.cos(rad);
                 let y = cy + r * Math.sin(rad);
                 pathPoints.push({x, y});
             }
        }
        else if (shape === 'infinity') {
            const a = 300;
            for (let t = 0; t < Math.PI * 2; t += 0.02) {
                const denom = 1 + Math.sin(t) * Math.sin(t);
                let x = cx + (a * Math.cos(t)) / denom;
                let y = cy + (a * Math.sin(t) * Math.cos(t)) / denom;
                pathPoints.push({x, y});
            }
        }
        else if (shape === 'heart') {
            cy = 650;
            const scale = 15;
            for (let t = 0; t < Math.PI * 2; t += 0.02) {
                let x = cx + scale * (16 * Math.pow(Math.sin(t), 3));
                let y = cy - scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                pathPoints.push({x, y});
            }
        }

        // å›ºå®šå…³å¡åˆå§‹åŒ–ï¼šé¢„ç”Ÿæˆçƒä½“
        if (GameConfig.levelMode === 'fixed') {
            // ç¡®ä¿è·¯å¾„ç”Ÿæˆå®Œæ¯•
            if (pathPoints.length > 0) {
                const totalBalls = GameConfig.fixedBallCount;
                // å‡åŒ€åˆ†å¸ƒåœ¨æ•´ä¸ªè·¯å¾„ä¸Š
                // ä¸ºé˜²æ­¢é¦–å°¾ç›¸æ¥å¤ªç´§ï¼Œç•™å‡ºä¸€æ®µç¼“å†²
                const step = Math.floor(pathPoints.length / totalBalls);
                
                for(let i=0; i<totalBalls; i++) {
                    let b = new Ball();
                    // å¼ºåˆ¶è®¾ç½® pathIndex
                    b.pathIndex = i * step;
                    b.updatePos();
                    balls.push(b);
                }
            }
        }
    }

    function findConnectedBalls(startBall) {
        // æŸ¥æ‰¾ä¸ startBall é¢œè‰²ç›¸åŒä¸”åœ¨è·¯å¾„ä¸Šç›¸é‚»çš„çƒ
        // ç®€å•å®ç°ï¼šæŒ‰è·¯å¾„ç´¢å¼•æ’åºï¼Œç„¶åå‘å‰åæœç´¢
        // 1. è·å–æ‰€æœ‰çƒå¹¶æŒ‰ pathIndex æ’åº
        let sortedBalls = [...balls].sort((a, b) => a.pathIndex - b.pathIndex);
        let targetIdx = sortedBalls.indexOf(startBall);
        if (targetIdx === -1) return [startBall];

        let connected = [startBall];
        
        // å‘å‰æœ
        for (let i = targetIdx - 1; i >= 0; i--) {
            let b = sortedBalls[i];
            let prevB = sortedBalls[i+1]; // ä¸Šä¸€ä¸ªåŠ å…¥çš„çƒï¼ˆé€»è¾‘ä¸Šæ˜¯åä¸€ä¸ªä½ç½®ï¼‰
            // è·ç¦»åˆ¤å®š (ç›´å¾„80ï¼Œç¨å¾®æ”¾å®½åˆ°90)
            let dist = Math.hypot(b.x - prevB.x, b.y - prevB.y);
            if (b.color === startBall.color && dist < 90) {
                connected.push(b);
            } else {
                break; // æ–­å¼€
            }
        }
        
        // å‘åæœ
        for (let i = targetIdx + 1; i < sortedBalls.length; i++) {
            let b = sortedBalls[i];
            let prevB = sortedBalls[i-1];
            let dist = Math.hypot(b.x - prevB.x, b.y - prevB.y);
            if (b.color === startBall.color && dist < 90) {
                connected.push(b);
            } else {
                break;
            }
        }
        
        return connected;
    }

    function update(dt) {
        if (isGameOver) return;

        // 1. æ›´æ–° Buff è®¡æ—¶å™¨
        if (activeBuffs.speed > 0) activeBuffs.speed -= dt / 1000;
        if (activeBuffs.slow > 0) activeBuffs.slow -= dt / 1000;
        if (activeBuffs.power > 0) activeBuffs.power -= dt / 1000;
        updateBuffUI();

        // è®¡ç®—å½“å‰çƒé€Ÿå€ç‡ (ä»… Slow å½±å“çƒé€Ÿ)
        // åŠ¨æ€å¿ƒæµï¼šéšç€åˆ†æ•°å¢åŠ ï¼Œçƒé€Ÿè‡ªç„¶åŠ å¿«
        // æ»¡åˆ† 5000 æ—¶ï¼Œé€Ÿåº¦è¾¾åˆ°åŸºç¡€é€Ÿåº¦çš„ 2.5 å€ (1.0 + 1.5)
        let flowFactor = 1 + (score / GameConfig.maxScore) * 1.5;
        let ballSpeedMult = 1.0 * flowFactor;

        if (activeBuffs.slow > 0) ballSpeedMult *= 0.5;

        // 2. ç”Ÿæˆçƒ (ä»…åœ¨éšæœºæ¨¡å¼ä¸‹)
        if (GameConfig.levelMode === 'random') {
            ballTimer += dt;
            if (ballTimer > GameConfig.ballSpawnInterval) {
                balls.push(new Ball());
                ballTimer = 0;
            }
        } else {
            // å›ºå®šæ¨¡å¼èƒœåˆ©æ£€æµ‹ï¼šåœºä¸Šæ— çƒå³å¯ (æ§½ä½é‡Œå‰©ä¸‹çš„ç®—æˆ˜åˆ©å“)
            if (balls.length === 0) {
                gameOver(true, 'CLEARED');
                return;
            }
        }

        // 3. æ›´æ–°çƒä½ç½®
        balls.forEach(b => b.update(ballSpeedMult));
        balls = balls.filter(b => !b.markedForDeletion);
        
        // 4. æŠ“é’©é€»è¾‘
        if (claw.state === 'IDLE') {
            // è‡ªåŠ¨å·¡é€»æ¨¡å¼
            if (GameConfig.controlMode === 'auto') {
                // Speed Buff åŠ é€ŸæŠ“é’©ç§»åŠ¨
                let clawSpeedMult = (activeBuffs.speed > 0) ? 2.0 : 1.0;
                claw.x += GameConfig.clawPatrolSpeed * claw.direction * clawSpeedMult;
                if (claw.x < 50 || claw.x > 700) claw.direction *= -1;
            }
            // æ‰‹åŠ¨æ¨¡å¼ä¸‹ claw.x ç”± pointermove äº‹ä»¶æ§åˆ¶ï¼Œæ­¤å¤„åªéœ€é™åˆ¶è¾¹ç•Œ
            else {
                claw.x = Math.max(50, Math.min(700, claw.x));
            }
            
            // æ¸¸æˆç»“æŸæ£€æµ‹ï¼šå½“æ§½ä½æ»¡ä¸”æŠ“é’©ç©ºé—²
            if (slots.length >= getMaxSlots()) {
                if (score >= GameConfig.passScore) {
                    gameOver(true, 'PASS');
                } else {
                    gameOver(false, 'FAIL');
                }
            }

        } else if (claw.state === 'DOWN') {
            // Speed Buff åŠ é€Ÿä¸‹è½ (æ‰‹åŠ¨æ¨¡å¼ä¸‹ä¹Ÿèƒ½å—ç›Š)
            let dropSpeedMult = (activeBuffs.speed > 0) ? 1.5 : 1.0;
            claw.y += GameConfig.clawDropSpeed * dropSpeedMult;
            
            // ç¢°æ’æ£€æµ‹
            if (claw.heldBalls.length === 0) {
                // éå†æ‰€æœ‰çƒ
                for (let b of balls) {
                    if (Math.hypot(claw.x - b.x, claw.y - b.y) < 70) {
                        // å‘½ä¸­ï¼
                        
                        // æ£€æŸ¥ Power Buff
                        if (activeBuffs.power > 0) {
                            // å¤§åŠ›æ¨¡å¼ï¼šæŠ“ä¸€ä¸²
                            const connected = findConnectedBalls(b);
                            connected.forEach(target => {
                                target.markedForDeletion = true;
                                claw.heldBalls.push({ color: target.color, buff: target.buff });
                            });
                        } else {
                            // æ™®é€šæ¨¡å¼ï¼šæŠ“ä¸€ä¸ª
                            b.markedForDeletion = true;
                            claw.heldBalls.push({ color: b.color, buff: b.buff });
                        }

                        claw.state = 'UP';
                        break;
                    }
                }
            }
            if (claw.y > 1200) claw.state = 'UP';

        } else if (claw.state === 'UP') {
            // Speed Buff åŠ é€Ÿå›æ”¶
            let dropSpeedMult = (activeBuffs.speed > 0) ? 1.5 : 1.0;
            claw.y -= GameConfig.clawDropSpeed * dropSpeedMult;
            
            if (claw.y <= claw.originY) {
                claw.y = claw.originY;
                claw.state = 'IDLE';
                
                // æ”¾å…¥æ§½ä½
                if (claw.heldBalls.length > 0) {
                    claw.heldBalls.forEach(b => slots.push(b));
                    claw.heldBalls = []; // æ¸…ç©ºæŠ“é’©
                    checkMatch();
                }
            }
        }

        // 5. ç²’å­
        particles.forEach(p => p.update());
    }

    function checkMatch() {
        if (slots.length === 0) return;
        
        const lastColor = slots[slots.length - 1].color;
        const matchingIndices = [];
        slots.forEach((s, index) => {
            if (s.color === lastColor) matchingIndices.push(index);
        });

        // ä½¿ç”¨é…ç½®çš„æ¶ˆé™¤é˜ˆå€¼
        if (matchingIndices.length >= getMatchThreshold()) {
            // è§¦å‘æ¶ˆé™¤
            let removedBuffs = [];
            
            // å€’åºåˆ é™¤ä»¥é˜²ç´¢å¼•é”™ä¹±ï¼Œæˆ–è€…ç›´æ¥filter
            // ä½†æˆ‘ä»¬éœ€è¦çŸ¥é“å“ªäº›çƒè¢«æ¶ˆé™¤äº†æ¥è§¦å‘Buff
            matchingIndices.forEach(idx => {
                // ç‰¹æ•ˆ
                // æ³¨æ„ï¼šå› ä¸ºslotså¯èƒ½è¶…è¿‡5ä¸ªï¼ŒUIç»˜åˆ¶ä½ç½®éœ€è¦åŠ¨æ€è®¡ç®—ï¼Œè¿™é‡Œç‰¹æ•ˆä¹ŸåŠ¨æ€è®¡ç®—
                // é‡æ–°è®¡ç®—ä½ç½®é€»è¾‘éœ€è¦ä¸ draw() ä¿æŒä¸€è‡´ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªç¡®ä¿å¤§æ¦‚ä½ç½®
                const maxSlots = getMaxSlots();
                const spacing = (maxSlots > 5) ? 80 : 125;
                const startX = (maxSlots > 5) ? 35 : 75;
                
                const bx = startX + (idx % maxSlots) * spacing;
                const by = 80 + Math.floor(idx / maxSlots) * 110; 
                for(let i=0; i<20; i++) particles.push(new Particle(bx, by, lastColor));
                
                // æ”¶é›†Buff
                if (slots[idx].buff && slots[idx].buff !== BUFF_TYPES.NONE) {
                    removedBuffs.push(slots[idx].buff);
                }
            });

            // çœŸæ­£ç§»é™¤
            slots = slots.filter(s => s.color !== lastColor);
            
            // åŠ åˆ†
            score += 100 * matchingIndices.length;
            updateScoreUI();

            // æ¿€æ´» Buff
            removedBuffs.forEach(buff => {
                if (buff === BUFF_TYPES.MYSTERY) {
                    blindBoxCount++;
                    updateBlindBoxUI();
                } else if (buff === BUFF_TYPES.SPEED) {
                    activeBuffs.speed = GameConfig.buffDuration;
                    activeBuffs.slow = 0; // äº’æ–¥
                } else if (buff === BUFF_TYPES.SLOW) {
                    activeBuffs.slow = GameConfig.buffDuration;
                    activeBuffs.speed = 0; // äº’æ–¥
                } else if (buff === BUFF_TYPES.POWER) {
                    activeBuffs.power = GameConfig.buffDuration;
                }
            });
        }
    }

    function draw() {
        ctx.clearRect(0,0,750,1334);

        // è½¨é“
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 20;
        for(let i=0; i<pathPoints.length; i++) {
            const p = pathPoints[i];
            if(i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // çƒä¸ç²’å­
        balls.forEach(b => b.draw(ctx));
        particles.forEach(p => p.draw(ctx));

        // æŠ“é’©ç»³å­
        ctx.beginPath();
        ctx.moveTo(claw.x, claw.originY - 100);
        ctx.lineTo(claw.x, claw.y);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 5;
        ctx.stroke();
        
        // æŠ“é’©å¤´ä¸æŒçƒ
        ctx.save();
        ctx.translate(claw.x, claw.y);
        
        // å¦‚æœæŠ“ç€çƒ
        if (claw.heldBalls.length > 0) {
            // ç”»ç¬¬ä¸€ä¸ªçƒä½œä¸ºä»£è¡¨ï¼Œæˆ–è€…ç”»ä¸€ä¸²ï¼Ÿç”»ä¸€ä¸²æ¯”è¾ƒé…·
            claw.heldBalls.forEach((b, i) => {
                ctx.beginPath(); 
                ctx.arc(0, 40 + i*60, 40, 0, Math.PI*2); // å‚ç›´ä¸²è”
                ctx.fillStyle = b.color; 
                ctx.fill();
            });
        }
        
        // é’©çˆªä¸»ä½“
        ctx.fillStyle = '#ffcc80';
        ctx.fillRect(-30, 0, 60, 40);
        
        // Power Buff è§†è§‰ç‰¹æ•ˆ (æŠ“é’©å‘å…‰)
        if (activeBuffs.power > 0) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.strokeRect(-32, -2, 64, 44);
        }
        
        ctx.restore();

        // æ§½ä½
        // åŠ¨æ€è®¡ç®—å¸ƒå±€
        const maxSlots = getMaxSlots();
        const slotCount = Math.max(maxSlots, slots.length);
        
        // åŠ¨æ€è°ƒæ•´èµ·å§‹ä½ç½®å’Œé—´è·ä»¥å±…ä¸­
        // é»˜è®¤ 750 å®½ã€‚
        // å¦‚æœ 5 ä¸ªï¼šé—´è· 125 (5*125=625)ï¼Œå±…ä¸­å‰© 125/2 = 62.5
        // å¦‚æœ 9 ä¸ªï¼šé—´è·éœ€è¦æ›´å°ã€‚ä¾‹å¦‚ 700å¯ç”¨ / 9 = 77ã€‚
        let slotW = 100; // æ¡†å¤§å°
        let spacing = (maxSlots > 5) ? 80 : 125;
        let startX = (750 - (maxSlots * spacing)) / 2 + (spacing/2) - 50; // ç²—ç•¥å±…ä¸­è®¡ç®—ï¼Œç›´æ¥å›ºå®šæ›´å¥½
        
        if (maxSlots > 5) startX = 35; // 9ä¸ªæ—¶çš„ç¡¬ç¼–ç èµ·å§‹ä½
        else startX = 75; // 5ä¸ªæ—¶çš„èµ·å§‹ä½
        
        for(let i=0; i<slotCount; i++) {
            // è®¡ç®—ä½ç½®
            const bx = startX + (i % maxSlots) * spacing;
            const by = 30 + Math.floor(i / maxSlots) * 110; 
            
            // åªç”»æœ€å¤§å®¹é‡å†…çš„èƒŒæ™¯æ¡†
            if (i < maxSlots) {
                ctx.strokeStyle = '#888';
                ctx.strokeRect(bx, 30, (maxSlots>5 ? 70 : 100), 100); // 9ä¸ªæ—¶æ¡†ç”»å°ç‚¹
            }
            
            if (slots[i]) {
                // çƒå¿ƒ
                let cx = bx + (maxSlots>5 ? 35 : 50);
                let cy = by + 50;
                let r = (maxSlots>5 ? 30 : 40); // 9ä¸ªæ—¶çƒç”»å°ç‚¹
                
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.fillStyle = slots[i].color; ctx.fill();
                
                // Buff æ ‡è®°
                if (slots[i].buff && slots[i].buff !== 'none') {
                    ctx.fillStyle = '#fff';
                    ctx.font = (maxSlots>5 ? '16px' : '20px') + ' Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let s = '';
                    if(slots[i].buff === 'mystery') s='â“';
                    if(slots[i].buff === 'speed') s='âš¡';
                    if(slots[i].buff === 'slow') s='ğŸ¢';
                    if(slots[i].buff === 'power') s='ğŸ’ª';
                    ctx.fillText(s, cx, cy);
                }
            }
        }
    }

    function gameOver(success, reason) {
        isGameOver = true;
        const modal = document.getElementById('game-over-modal');
        const title = document.getElementById('modal-title');
        const desc = document.getElementById('modal-desc');
        const boxArea = document.getElementById('blind-box-area');
        
        modal.style.display = 'flex';
        
        if (success) {
            title.innerText = reason === 'FULL' ? "ğŸ‰ å®Œç¾é€šå…³ï¼" : "âœ… æŒ‘æˆ˜æˆåŠŸï¼";
            title.style.color = "#00f2fe";
        } else {
            title.innerText = "ğŸ’” æ¸¸æˆç»“æŸ";
            title.style.color = "#ff4444";
        }
        
        desc.innerText = `æœ€ç»ˆå¾—åˆ†: ${score}`;
        
        // ç»“ç®—ç›²ç›’
        if (blindBoxCount > 0) {
            boxArea.style.display = 'block';
            document.getElementById('box-count').innerText = blindBoxCount;
            const resContainer = document.getElementById('blind-box-result');
            resContainer.innerHTML = '';
            
            // ç®€å•çš„å¼€ç›²ç›’åŠ¨ç”»æ•ˆæœ
            for(let i=0; i<blindBoxCount; i++) {
                setTimeout(() => {
                    const box = document.createElement('div');
                    box.className = 'box-opened';
                    // éšæœºå¥–åŠ±æ–‡æ¡ˆ
                    const rewards = ['ğŸ’', 'ğŸ¬', 'ğŸ§¸', 'ğŸˆ', 'ğŸ’°'];
                    box.innerText = rewards[Math.floor(Math.random()*rewards.length)];
                    resContainer.appendChild(box);
                }, i * 300);
            }
        } else {
            boxArea.style.display = 'none';
        }
    }

    function resetGame() {
        isGameOver = false;
        score = 0;
        slots = [];
        balls = []; // initPathä¼šå†æ¬¡æ¸…ç©ºï¼Œä½†è¿™é‡Œæ˜¾å¼ä¸€ç‚¹
        blindBoxCount = 0;
        activeBuffs = { speed:0, slow:0, power:0 };
        claw.state = 'IDLE';
        claw.heldBalls = [];
        
        document.getElementById('game-over-modal').style.display = 'none';
        updateScoreUI();
        updateBuffUI();
        updateBlindBoxUI();
        initPath();
        
        // é‡æ–°å¯åŠ¨å¾ªç¯ (å¦‚æœä¹‹å‰åœæ­¢äº†çš„è¯ï¼Œä½†æˆ‘ä»¬å…¶å®æ²¡åœæ­¢RAFï¼Œåªæ˜¯returnäº†)
        // updateä¸­åŠ äº† isGameOver æ£€æŸ¥ï¼Œæ‰€ä»¥åªéœ€è¦é‡ç½®å˜é‡å³å¯
    }

    function loop(timestamp) {
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        
        // é™åˆ¶æœ€å¤§å¸§é—´éš”ï¼Œé˜²æ­¢åˆ‡æ¢åå°å›æ¥åé£é€Ÿè¿è¡Œ
        const safeDt = Math.min(dt, 50);
        
        update(safeDt);
        draw();
        
        requestAnimationFrame(loop);
    }

    // ç»‘å®šUIäº‹ä»¶
    function bindDebugPanel() {
        const bind = (id, key, needsPathUpdate = false) => {
            const input = document.getElementById('inp-' + id);
            const display = document.getElementById('val-' + id);
            
            if (!display) {
                input.addEventListener('change', (e) => {
                    GameConfig[key] = e.target.value;
                    if (needsPathUpdate) initPath();
                });
                return;
            }
            
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                GameConfig[key] = val;
                display.innerText = val;
                if (needsPathUpdate) initPath();
            });
        };

        bind('speed', 'ballSpeed');
        bind('spawn', 'ballSpawnInterval');
        bind('trackShape', 'trackShape', true);
        
        // SlotLimit ç‰¹æ®Šå¤„ç†ï¼šinputæ›´æ–°æ˜¾ç¤ºï¼Œchangeæ›´æ–°é…ç½®å¹¶é‡ç½®
        const sInp = document.getElementById('inp-slotLimit');
        const sVal = document.getElementById('val-slotLimit');
        sInp.addEventListener('input', (e) => {
            sVal.innerText = e.target.value;
        });
        sInp.addEventListener('change', (e) => {
             GameConfig.slotLimit = parseInt(e.target.value);
             resetGame();
        });
        
        // ç»‘å®šæ–°æ¨¡å¼æ§ä»¶ (å˜æ›´æ—¶é‡ç½®æ¸¸æˆ)
        ['matchMode', 'levelMode', 'controlMode'].forEach(key => {
            document.getElementById('inp-' + key).addEventListener('change', (e) => {
                GameConfig[key] = e.target.value;
                
                // ç‰¹æ®Šè”åŠ¨ï¼šmatchMode å½±å“ slotLimit
                if (key === 'matchMode') {
                    const slotGroup = document.getElementById('group-slotLimit');
                    const slotInp = document.getElementById('inp-slotLimit');
                    const slotVal = document.getElementById('val-slotLimit');
                    
                    if (GameConfig.matchMode === 'match3') {
                        slotGroup.style.display = 'block';
                        GameConfig.slotLimit = parseInt(slotInp.value); // æ¢å¤ä¹‹å‰çš„è®¾å®š
                    } else {
                        slotGroup.style.display = 'none';
                        GameConfig.slotLimit = 5;
                    }
                }
                
                resetGame();
            });
        });
    }

    // äº¤äº’
    canvas.addEventListener('pointermove', (e) => {
        if (GameConfig.controlMode === 'manual' && claw.state === 'IDLE' && !isGameOver) {
            // è·å– Canvas åœ¨å±å¹•ä¸Šçš„ä½ç½®å’Œç¼©æ”¾æ¯”ä¾‹
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            
            // è®¡ç®—é¼ æ ‡åœ¨ Canvas å†…çš„ X åæ ‡
            let x = (e.clientX - rect.left) * scaleX;
            claw.x = x; // è¾¹ç•Œé™åˆ¶åœ¨ update() ä¸­ç»Ÿä¸€å¤„ç†
        }
    });

    canvas.addEventListener('pointerdown', (e) => {
        if (isGameOver) return;
        if (claw.state === 'IDLE') {
            // åªæœ‰å½“ä¸æ»¡æˆ–è€…å¤„äºPoweræ¨¡å¼ä¸‹(è™½ç„¶Poweræ¨¡å¼ä¸‹ä¹Ÿæ˜¯IDLEæ‰èƒ½ä¸‹è½ï¼Œä½†é€šå¸¸æ»¡äº†å°±ç»“æŸäº†)
            // å‡†ç¡®è¯´æ˜¯ï¼šå¦‚æœæœªæ»¡5ä¸ªï¼Œå…è®¸æŠ“ã€‚
            // ä¹‹å‰é€»è¾‘æ˜¯æ»¡äº†5ä¸ªç›´æ¥åˆ¤è¾“ã€‚æ‰€ä»¥åœ¨GameOverå‰ç©å®¶å·²ç»åŠ¨ä¸äº†äº†ã€‚
            if (slots.length < getMaxSlots()) {
                claw.state = 'DOWN';
            }
        }
    });

    // å¯åŠ¨
    bindDebugPanel();
    initPath();
    requestAnimationFrame(loop);

</script>
</body>
</html>